# 8. **Inference from usage:** How does TypeScript infer generics from arguments & return types? Whatâ€™s â€œbest common typeâ€?

## a

I really need help on this one. All I know is inference happens within the function. 

## A

Good â€” thatâ€™s a perfect starting foothold. â€œInferenceâ€ is just TypeScriptâ€™s way of filling in generic type parameters **automatically** from how a function is used. But there are several moving parts: *where inference happens*, *what info it uses*, and *how it decides a â€œbest common type.â€*

Letâ€™s break it down like a mechanic pulling apart a watch.

---

### ğŸ§© 1) The flow of inference

When you call a generic function, TS looks at your **arguments**, **context**, and sometimes the **expected return type** to guess what type parameter fits.

```ts
function identity<T>(value: T): T {
  return value;
}

const a = identity("hi");  // T = string
const b = identity(42);    // T = number
```

You didnâ€™t specify `<string>` or `<number>`; TS inferred it.

So:

* It first looks at **arguments** â†’ what types are passed?
* Then it looks at **return position** â†’ what type is expected on the left-hand side?
* Finally, it reconciles them into the most specific, consistent type possible.

---

### ğŸ§  2) â€œBidirectionalâ€ inference

Inference flows both ways in some contexts â€” **from arguments to parameters**, but also **from expected return type back into generics**.

```ts
const pair = <T>(x: T) => [x, x];

const xs = pair(1);   // T = number, result: number[]
const ys: string[] = pair("a"); // expected type gives context too
```

Another common example:

```ts
function map<T, U>(arr: T[], fn: (x: T) => U): U[] {
  return arr.map(fn);
}

const res = map(["a", "b"], x => x.length);
//   T = string
//   U = number (inferred from return of the callback)
```

Here inference is *contextual* â€” it sees that the callback returns a number, so it infers `U = number`.

---

### ğŸ§® 3) â€œBest common typeâ€

When inferring from a list of expressions (like an array literal), TS tries to find a **type all elements can share** â€” the *best common type.*

```ts
const nums = [1, 2, 3]; // number[]
const mix = [1, "a", true]; // (string | number | boolean)[]
```

If multiple candidates exist, it walks up the type hierarchy to find a union or base type. This is called *best common type inference.*

```ts
class Dog { bark() {} }
class Cat { meow() {} }

const pets = [new Dog(), new Cat()];
// best common type = (Dog | Cat)[]
```

It tries to keep the array homogeneous while preserving all member types.

Pitfall: if types are too disjoint or widen differently, you get `any[]`.

```ts
const arr = [1, null]; // (number | null)[]
const arr2 = []; arr2.push(1); arr2.push("a");
// arr2: (string | number)[]
```

---

### âš™ï¸ 4) Inference with defaults

Defaults (`<T = something>`) fill in when inference fails:

```ts
function makeSet<T = string>(values?: T[]) {
  return new Set(values);
}

const s = makeSet();        // T = string (default used)
const s2 = makeSet([true]); // T = boolean (inferred)
```

---

### âš”ï¸ 5) Where inference *stops working*

* With unrelated arguments: `T` canâ€™t unify â†’ becomes a union or `unknown`.
* With overloads, inference can pick the wrong branch.
* When you explicitly annotate one argument in a conflicting way, inference stops for others.

```ts
function wrap<T>(x: T, y: T) { return [x, y]; }
wrap(1, "a"); // T inferred as string | number
```

---

### ğŸ’¬ Interview-ready answer

> TypeScript infers generic parameters from **how a function is used**.
>
> It first looks at the **arguments** and the **expected return type** to find the most specific type that satisfies both. This can be one-way (from arguments) or bidirectional (from context).
>
> When there are multiple possible element types â€” like an array literal â€” it computes the **best common type**, which is basically the smallest union or shared supertype that covers all members.
>
> If inference fails, defaults like `<T = string>` step in. In general, TS tries to infer as precisely as possible without you needing to write the generic yourself.

---

Want to tackle **Q9: Variance** next? Itâ€™s gnarly but funâ€”especially since React props are a real-world example of contravariance.
