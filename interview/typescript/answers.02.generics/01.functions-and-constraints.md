# 7. **Generic functions and constraints:** Show how `extends` constraints work and when to prefer defaults (`<T = …>`).

## a

Please help with this one.

## A

Love this one—generics are where TypeScript stops being “lint with vibes” and starts being a real power tool. Here’s the clean, interview-ready tour of **constraints with `extends`** and **default generic parameters** (`<T = …>`), with practical patterns.

---

### What to know (and show)

#### 1) `extends` puts *requirements* on a type parameter

Use it to guarantee a shape, primitive family, or key relationship.

```ts
// Require an object with a length
function len<T extends { length: number }>(x: T): number {
  return x.length;
}

// Key-safe property access
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// “ID-bearing” items can be indexed into a map
function indexById<T extends { id: string }>(items: T[]): Record<string, T> {
  return Object.fromEntries(items.map(i => [i.id, i]));
}

// Restrict to certain primitives
function toArray<T extends string | number>(x: T | T[]) : T[] {
  return Array.isArray(x) ? x : [x];
}
```

Common constraint choices and their tradeoffs:

* `T extends { ... }` — precise, great for object shapes.
* `T extends object` — excludes primitives, but too loose to give property safety.
* Prefer `Record<string, unknown>` over `{ [k: string]: any }` to keep type safety.
* `K extends keyof T` — the classic *key relationship* pattern.

#### 2) Default generic parameters (`<T = …>`)

Defaults kick in **only if TS cannot infer** the type argument *and* you didn’t supply one. They’re for ergonomics and backward compatibility.

```ts
// Default common case to string
function makeSet<T = string>(initial?: T[]): Set<T> {
  return new Set(initial);
}

const s1 = makeSet();                 // Set<string>
const s2 = makeSet<number>([1, 2]);   // Set<number>
const s3 = makeSet([true, false]);    // Set<boolean> (inferred, default ignored)
```

Great places for defaults:

* Factories with optional inputs.
* Hooks/components where you want a sensible baseline.
* When introducing a **new** type parameter to a public API without breaking callers.

React-flavored example:

```ts
type OptionBase = { label: string; value: string };

function Select<Option = OptionBase>(props: {
  options: Option[];
  getLabel?: (o: Option) => string;
  onChange: (o: Option) => void;
}) {
  /* ... */
}

// Common case (no generic supplied): OptionBase
<Select options={[{ label: "A", value: "a" }]} onChange={() => {}} />

// Custom shape inferred from props:
<Select
  options={[{ id: 1, name: "A" }]}
  getLabel={o => o.name}
  onChange={o => o.id}
/>
```

#### 3) Constraints + defaults together

You can default **and** restrict:

```ts
// K defaults to all keys, but must be keys of T
type PickByDefault<T, K extends keyof T = keyof T> = { [P in K]: T[P] };
```

---

### Pitfalls (mention succinctly)

* Using `{}` or `object` as a constraint when you actually need a property → prefer `{ foo: … }` or `Record<string, …>`.
* Default generics won’t apply if inference already found a type—don’t rely on defaults to “win” against inference.
* Over-constraining (`T extends SomeSpecificType`) harms reuse; under-constraining (`T extends object`) loses safety. Aim for the **minimal shape you truly need**.

---

### Interview-ready answer

> I use `extends` on generics to state the **capabilities** a type must have—e.g., `T extends { length: number }` if I’m going to access `.length`, or `K extends keyof T` to keep property access safe.
>
> For ergonomics, I add **default generic parameters** like `<T = string>` so callers get a sensible type when inference can’t determine one, and to preserve backwards compatibility when I introduce new type parameters.
>
> In practice: helpers like `getProp<T, K extends keyof T>(obj, key): T[K]`, collections like `indexById<T extends { id: string }>()`, and UI generics—`Select<Option = OptionBase>`—where callers can let defaults work or supply a custom shape. The rule of thumb is: **constrain only what you need**, and use defaults to make the common case zero-config without fighting inference.

---

Want to tackle **Q8: Inference from usage & “best common type”** next, or hop to a practical like **P5 `RequiredBy<T, K>`** so we can flex these patterns with tests?
