# 10. **Overloads vs generics:** When are overloads clearer? When are they a smell?

## a

I don't know the difference. Please help

## A

Perfect â€” this one trips up a lot of senior devs, so youâ€™re in good company.
Letâ€™s untangle what *function overloads* actually are in TypeScript, how they differ from *generics*, and when each one makes your code betterâ€”or worse.

---

### ğŸ§© Step 1: What overloads *really* are

In **TypeScript**, an **overload** means you declare **multiple call signatures** for a single function.
Only one implementation exists, but TypeScript lets you expose several ways to call it:

```ts
// Overload signatures (only types)
function get(id: number): User;
function get(name: string): User[];

// Single implementation
function get(arg: number | string): User | User[] {
  if (typeof arg === "number") return { id: arg, name: "Cher" };
  return [{ id: 1, name: arg }];
}

get(1);       // User
get("Cher");  // User[]
```

Here weâ€™re saying:

> â€œIf you call `get` with a number, you get one user.
> If you call it with a string, you get an array.â€

At runtime itâ€™s one function; at compile time, the overloads tell TS what to expect for each call.

---

### ğŸ§  Step 2: What generics do instead

Generics describe **a relationship between input and output types** that holds across calls.
You donâ€™t write multiple signatures; you parameterize one.

```ts
function identity<T>(x: T): T {
  return x;
}

identity("hi"); // T = string
identity(42);   // T = number
```

You could emulate the `get()` overload with generics too:

```ts
function get<T extends number | string>(
  arg: T
): T extends number ? User : User[] {
  if (typeof arg === "number") return { id: arg, name: "Cher" } as any;
  return [{ id: 1, name: arg }] as any;
}
```

Thatâ€™s one function signature with a *conditional return type* depending on `T`.

---

### âš–ï¸ Step 3: When overloads are **clearer**

Use overloads when:

* There are **few discrete, human-meaningful variants** of a call (not an infinite family).
* Each variantâ€™s behavior is conceptually different enough to warrant separate doc lines.

Examples:

```ts
function query(selector: string): Element | null;
function query(selector: string, all: true): NodeListOf<Element>;
```

Or for event handlers:

```ts
function on(event: "click", cb: (e: MouseEvent) => void): void;
function on(event: "keydown", cb: (e: KeyboardEvent) => void): void;
```

Thatâ€™s readable, ergonomic, and self-documenting.

---

### ğŸ§¨ Step 4: When overloads become a **smell**

Overloads are a smell when:

* Youâ€™re enumerating tons of combinations (`string | number | boolean | ...` overloads).
* The overloads differ only by type shape, not logic.
* You start repeating the same implementation logic for each overload.

This usually means: **use generics or unions instead.**

Example of a â€œsmellyâ€ overload:

```ts
function wrap(x: string): string[];
function wrap(x: number): number[];
function wrap(x: boolean): boolean[];
function wrap(x: any): any[] {
  return [x];
}
```

Better as:

```ts
function wrap<T>(x: T): T[] {
  return [x];
}
```

---

### âš™ï¸ Step 5: Hybrid approach (sometimes best)

You can combine overloads + generics: discrete overloads for distinct categories, each parameterized.

```ts
function fetchData(url: string): Promise<string>;
function fetchData(url: string, json: true): Promise<Record<string, unknown>>;
function fetchData(url: string, json?: boolean): Promise<any> {
  return fetch(url).then(r => json ? r.json() : r.text());
}
```

Thatâ€™s good: two semantically distinct modes.

---

### ğŸ§© Step 6: Practical hints

* **Overloads = better docs, simpler reading** for human categories.
* **Generics = better composability and maintainability** when youâ€™re expressing type relationships.
* Too many overloads â†’ code smells like â€œmanual inference.â€
* Too complex generics â†’ unreadable code. Balance matters.

---

### ğŸ’¬ Interview-ready answer

> Overloads let you define multiple *call signatures* for one implementation. Theyâ€™re great when a function has a small number of distinct usage patternsâ€”like â€œcall with ID returns one user; call with name returns many.â€
>
> Generics, on the other hand, express *a relationship* between input and output types in one consistent signature. They scale better for families of similar calls.
>
> Overloads become a smell when you find yourself repeating the same logic for slightly different types; that usually means you should use generics or unions instead.
>
> I like overloads for API ergonomics, and generics for generality and type safety.

---

Want to move into **Q11 â€“ Mapped & conditional types** next? Thatâ€™s where TypeScript starts feeling like a miniature programming language inside itself.
