# 3. **Variance:** What does it mean here? Give a React-prop style example where variance matters.

## a

Seriously please help here.

## A

Good â€” this one *sounds* like abstract math, but itâ€™s just TypeScript being picky about whoâ€™s allowed to stand in for whom.
Variance describes **how subtyping relationships behave when you wrap types inside other types**â€”like â€œif `Cat` extends `Animal`, does `Box<Cat>` extend `Box<Animal>`?â€

Letâ€™s translate that to the TypeScript + React world.

---

### ğŸ§© Step 1: The idea of variance, with animals first

Suppose:

```ts
class Animal {}
class Dog extends Animal {}
```

We all agree: `Dog` **extends** `Animal`.
Now, what about these?

```ts
type Box<T> = { value: T };
```

Is `Box<Dog>` assignable to `Box<Animal>`?

* If **yes**, thatâ€™s *covariance* (â€œgoes the same wayâ€).
* If **no**, thatâ€™s *invariance* (â€œyou canâ€™t substitute itâ€).
* If **opposite**, thatâ€™s *contravariance*.
* If it works both ways, *bivariance* (dangerous, but sometimes tolerated for practicality).

---

### ğŸ§  Step 2: Covariance (most things)

For immutable containersâ€”arrays, `Promise<T>`, return valuesâ€”TypeScript treats generics as **covariant**.

```ts
let dogs: Dog[] = [new Dog()];
let animals: Animal[] = dogs; // âœ… arrays are covariant in TS
```

Thatâ€™s okay *until you mutate*:

```ts
animals.push(new Animal()); // âŒ runtime problem: now dogs[] has a non-dog
```

So TypeScript actually makes arrays **mutable covariant**, which is an â€œunsafe convenience.â€

---

### âš™ï¸ Step 3: Contravariance (function parameters)

Function parameter types are *contravariant*:
A function that expects a general `Animal` can accept a function that expects a *more specific* `Dog`, but not vice versa.

```ts
type Handler<T> = (x: T) => void;

let handleAnimal: Handler<Animal> = a => console.log("animal", a);
let handleDog: Handler<Dog> = d => console.log("dog", d);

handleAnimal = handleDog; // âŒ not safe
handleDog = handleAnimal; // âœ… ok
```

Why?
A handler that can deal with *any* animal is safe to use where a dog handler is expected, but not the other way around. Thatâ€™s contravariance.

---

### ğŸ§© Step 4: React propsâ€”variance in practice

Props are effectively **function parameters**:
A component is something like `(props: Props) => ReactNode`.

So prop types are **contravariant**.

Example:

```tsx
type AnimalProps = { name: string; onSelect: (a: Animal) => void };
type DogProps = { name: string; onSelect: (a: Dog) => void };

const AnimalCard = (props: AnimalProps) => null;
const DogCard = (props: DogProps) => null;

// Question: can a DogCard be used where an AnimalCard is expected?
const renderAnimalCard = (Comp: (p: AnimalProps) => JSX.Element) => {
  const dog: Dog = new Dog();
  Comp({ name: "Fido", onSelect: a => console.log(a) });
};

// âŒ This fails:
renderAnimalCard(DogCard);
```

Why?
`DogCard` expects an `onSelect` that receives a **Dog**, but `renderAnimalCard` might pass an `Animal`.
Thatâ€™s unsafe, so TS forbids it â€” contravariance at work.

If you flip it:

```tsx
renderAnimalCard(AnimalCard); // âœ… fine
```

Thatâ€™s safe because `AnimalCard` can handle anything.

---

### ğŸª„ Step 5: Return types (covariant)

If a function *returns* a value, those return types are **covariant**:
a function returning `Dog` can stand in for one returning `Animal` (since Dog âŠ‚ Animal).

So props (inputs) â†’ contravariant,
returns (outputs) â†’ covariant.
This is the basic â€œinput/outputâ€ mental model.

---

### âš ï¸ Step 6: Practical consequence in React

You sometimes see this when defining HOCs or generic components:

```tsx
function withLoading<P>(Component: React.ComponentType<P>) {
  return (props: P & { loading: boolean }) =>
    props.loading ? <Spinner /> : <Component {...props} />;
}
```

That `<P>` must be **contravariant** for props; if it were covariant, you could accidentally pass a component expecting *narrower* props than you supply.

TypeScript handles this behind the scenes using something called *bivariance*, which is why some unsafe prop substitutions still compile â€” it trades mathematical purity for developer sanity.

---

### ğŸ’¬ Interview-ready answer

> Variance describes how subtyping behaves inside generic types.
>
> If a subtype relationship moves in the **same direction** (Dog â†’ Animal means Box<Dog> â†’ Box<Animal>), thatâ€™s **covariance**.
> If it moves in the **opposite direction** (function parameters), thatâ€™s **contravariance**.
>
> In React, props are contravariant because components are just functions receiving props. A component expecting a `Dog` prop canâ€™t safely substitute for one expecting an `Animal` prop, but the opposite is fine.
>
> Understanding variance matters when writing higher-order components or event handlers â€” it explains why some prop substitutions type-check and others donâ€™t.

---

Want to tackle **Q10 â€“ Overloads vs generics** next (nice and concrete after this abstract one)?
