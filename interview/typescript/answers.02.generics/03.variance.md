# 3. **Variance:** What does it mean here? Give a React-prop style example where variance matters.

## a

Seriously please help here.

## A

Good — this one *sounds* like abstract math, but it’s just TypeScript being picky about who’s allowed to stand in for whom.
Variance describes **how subtyping relationships behave when you wrap types inside other types**—like “if `Cat` extends `Animal`, does `Box<Cat>` extend `Box<Animal>`?”

Let’s translate that to the TypeScript + React world.

---

### 🧩 Step 1: The idea of variance, with animals first

Suppose:

```ts
class Animal {}
class Dog extends Animal {}
```

We all agree: `Dog` **extends** `Animal`.
Now, what about these?

```ts
type Box<T> = { value: T };
```

Is `Box<Dog>` assignable to `Box<Animal>`?

* If **yes**, that’s *covariance* (“goes the same way”).
* If **no**, that’s *invariance* (“you can’t substitute it”).
* If **opposite**, that’s *contravariance*.
* If it works both ways, *bivariance* (dangerous, but sometimes tolerated for practicality).

---

### 🧠 Step 2: Covariance (most things)

For immutable containers—arrays, `Promise<T>`, return values—TypeScript treats generics as **covariant**.

```ts
let dogs: Dog[] = [new Dog()];
let animals: Animal[] = dogs; // ✅ arrays are covariant in TS
```

That’s okay *until you mutate*:

```ts
animals.push(new Animal()); // ❌ runtime problem: now dogs[] has a non-dog
```

So TypeScript actually makes arrays **mutable covariant**, which is an “unsafe convenience.”

---

### ⚙️ Step 3: Contravariance (function parameters)

Function parameter types are *contravariant*:
A function that expects a general `Animal` can accept a function that expects a *more specific* `Dog`, but not vice versa.

```ts
type Handler<T> = (x: T) => void;

let handleAnimal: Handler<Animal> = a => console.log("animal", a);
let handleDog: Handler<Dog> = d => console.log("dog", d);

handleAnimal = handleDog; // ❌ not safe
handleDog = handleAnimal; // ✅ ok
```

Why?
A handler that can deal with *any* animal is safe to use where a dog handler is expected, but not the other way around. That’s contravariance.

---

### 🧩 Step 4: React props—variance in practice

Props are effectively **function parameters**:
A component is something like `(props: Props) => ReactNode`.

So prop types are **contravariant**.

Example:

```tsx
type AnimalProps = { name: string; onSelect: (a: Animal) => void };
type DogProps = { name: string; onSelect: (a: Dog) => void };

const AnimalCard = (props: AnimalProps) => null;
const DogCard = (props: DogProps) => null;

// Question: can a DogCard be used where an AnimalCard is expected?
const renderAnimalCard = (Comp: (p: AnimalProps) => JSX.Element) => {
  const dog: Dog = new Dog();
  Comp({ name: "Fido", onSelect: a => console.log(a) });
};

// ❌ This fails:
renderAnimalCard(DogCard);
```

Why?
`DogCard` expects an `onSelect` that receives a **Dog**, but `renderAnimalCard` might pass an `Animal`.
That’s unsafe, so TS forbids it — contravariance at work.

If you flip it:

```tsx
renderAnimalCard(AnimalCard); // ✅ fine
```

That’s safe because `AnimalCard` can handle anything.

---

### 🪄 Step 5: Return types (covariant)

If a function *returns* a value, those return types are **covariant**:
a function returning `Dog` can stand in for one returning `Animal` (since Dog ⊂ Animal).

So props (inputs) → contravariant,
returns (outputs) → covariant.
This is the basic “input/output” mental model.

---

### ⚠️ Step 6: Practical consequence in React

You sometimes see this when defining HOCs or generic components:

```tsx
function withLoading<P>(Component: React.ComponentType<P>) {
  return (props: P & { loading: boolean }) =>
    props.loading ? <Spinner /> : <Component {...props} />;
}
```

That `<P>` must be **contravariant** for props; if it were covariant, you could accidentally pass a component expecting *narrower* props than you supply.

TypeScript handles this behind the scenes using something called *bivariance*, which is why some unsafe prop substitutions still compile — it trades mathematical purity for developer sanity.

---

### 💬 Interview-ready answer

> Variance describes how subtyping behaves inside generic types.
>
> If a subtype relationship moves in the **same direction** (Dog → Animal means Box<Dog> → Box<Animal>), that’s **covariance**.
> If it moves in the **opposite direction** (function parameters), that’s **contravariance**.
>
> In React, props are contravariant because components are just functions receiving props. A component expecting a `Dog` prop can’t safely substitute for one expecting an `Animal` prop, but the opposite is fine.
>
> Understanding variance matters when writing higher-order components or event handlers — it explains why some prop substitutions type-check and others don’t.

---

Want to tackle **Q10 – Overloads vs generics** next (nice and concrete after this abstract one)?
