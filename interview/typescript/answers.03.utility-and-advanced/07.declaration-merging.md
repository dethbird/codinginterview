# 17. **Declaration merging & module augmentation:** When you’d extend a third-party lib’s types safely.

## a

## A

Excellent — this one’s more *meta-TypeScript*: it’s about how the compiler merges multiple declarations for the same identifier, and how you can extend or “patch” existing module types when you don’t own them. It’s also a place where you can break everything if you’re careless, so let’s cover the safe way.

---

## 🧩 1) Declaration merging in general

TypeScript merges separate declarations that share a name **when they’re in the same scope**.
The most common merges happen between:

* **Interfaces**
* **Namespaces and functions/classes/enums**

Example:

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// ✅ merged automatically
const u: User = { name: "Cher", age: 3 };
```

That’s **declaration merging** — TypeScript unites them into one interface.

You can also merge a **namespace** with a **class or function** to add static members:

```ts
function greet(name: string) {
  return `Hello ${name}`;
}

namespace greet {
  export const version = "1.0";
}

greet.version; // ✅ "1.0"
```

---

## 🧠 2) Module augmentation

That same mechanism works *across modules* — called **module augmentation**.
You can reopen an imported module’s type declarations and safely extend them.

This is what you do when you need to teach TypeScript about **new properties** or **custom APIs** you’re adding to a third-party library.

Example:
Let’s say you use `express` and want to attach a `user` object to every `Request`.

```ts
// Somewhere in your project (usually in src/types/express.d.ts)
import "express";  // important: augment, don’t re-declare

declare module "express-serve-static-core" {
  interface Request {
    user?: { id: string; name: string };
  }
}
```

Now everywhere in your project:

```ts
app.use((req, res, next) => {
  req.user = { id: "1", name: "Cher" }; // ✅
  next();
});
```

You’ve **augmented** the existing `Request` interface exported by `express-serve-static-core`.

---

## ⚙️ 3) Safe patterns

* Always `import "lib-name";` first, **then** declare `module "lib-name"` — that tells TS to *merge* instead of overwrite.
* Keep augmentations in a `.d.ts` file included by `tsconfig.json`’s `"include"` array.
* Avoid default exports inside augmentation blocks.
* Don’t redeclare things from scratch; only **extend**.
* Prefix interfaces when the module’s shape isn’t guaranteed stable (`declare global { namespace JSX { ... } }` also common).

---

## 🧩 4) Common real-world augmentations

**Express Request / Response**

```ts
declare module "express-serve-static-core" {
  interface Request {
    user?: User;
  }
}
```

**Next.js API Routes**

```ts
declare module "next" {
  interface NextApiRequest {
    user?: { id: string };
  }
}
```

**Jest globals**

```ts
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeWithinRange(a: number, b: number): R;
    }
  }
}
```

**React JSX**

```ts
declare global {
  namespace JSX {
    interface IntrinsicElements {
      "my-widget": { label?: string };
    }
  }
}
```

---

## ⚠️ 5) Pitfalls and safety notes

* **Don’t use `declare module "*"`** unless you mean to define a catch-all fallback; it disables checking.
* **Don’t duplicate** interfaces with identical property names but different types — merges silently overwrite and confuse IntelliSense.
* **Library updates** can break your augmentation if upstream adds the same property name with a different type.

---

## 💬 Interview-ready answer

> Declaration merging happens when TypeScript unites multiple declarations with the same name — usually interfaces or namespaces.
>
> Module augmentation uses that mechanism to safely extend a third-party module’s types.
> For example:
>
> ```ts
> import "express";
> declare module "express-serve-static-core" {
>   interface Request { user?: { id: string } }
> }
> ```
>
> That way, the compiler knows `req.user` exists everywhere, and we didn’t have to fork the library.
> It’s safe as long as you *import then declare*, keep augmentations in `.d.ts` files, and avoid redefining existing properties.
> It’s a core tool for adding framework-specific context (Express, Next.js, Jest, JSX) without patching dependencies.

---

Next up is **Q18 – `tsconfig` essentials** — that’s about strictness flags and how they shape your type-safety boundary. Want to roll into that?
