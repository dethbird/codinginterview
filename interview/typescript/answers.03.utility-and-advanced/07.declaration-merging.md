# 17. **Declaration merging & module augmentation:** When youâ€™d extend a third-party libâ€™s types safely.

## a

## A

Excellent â€” this oneâ€™s more *meta-TypeScript*: itâ€™s about how the compiler merges multiple declarations for the same identifier, and how you can extend or â€œpatchâ€ existing module types when you donâ€™t own them. Itâ€™s also a place where you can break everything if youâ€™re careless, so letâ€™s cover the safe way.

---

## ğŸ§© 1) Declaration merging in general

TypeScript merges separate declarations that share a name **when theyâ€™re in the same scope**.
The most common merges happen between:

* **Interfaces**
* **Namespaces and functions/classes/enums**

Example:

```ts
interface User {
  name: string;
}

interface User {
  age: number;
}

// âœ… merged automatically
const u: User = { name: "Cher", age: 3 };
```

Thatâ€™s **declaration merging** â€” TypeScript unites them into one interface.

You can also merge a **namespace** with a **class or function** to add static members:

```ts
function greet(name: string) {
  return `Hello ${name}`;
}

namespace greet {
  export const version = "1.0";
}

greet.version; // âœ… "1.0"
```

---

## ğŸ§  2) Module augmentation

That same mechanism works *across modules* â€” called **module augmentation**.
You can reopen an imported moduleâ€™s type declarations and safely extend them.

This is what you do when you need to teach TypeScript about **new properties** or **custom APIs** youâ€™re adding to a third-party library.

Example:
Letâ€™s say you use `express` and want to attach a `user` object to every `Request`.

```ts
// Somewhere in your project (usually in src/types/express.d.ts)
import "express";  // important: augment, donâ€™t re-declare

declare module "express-serve-static-core" {
  interface Request {
    user?: { id: string; name: string };
  }
}
```

Now everywhere in your project:

```ts
app.use((req, res, next) => {
  req.user = { id: "1", name: "Cher" }; // âœ…
  next();
});
```

Youâ€™ve **augmented** the existing `Request` interface exported by `express-serve-static-core`.

---

## âš™ï¸ 3) Safe patterns

* Always `import "lib-name";` first, **then** declare `module "lib-name"` â€” that tells TS to *merge* instead of overwrite.
* Keep augmentations in a `.d.ts` file included by `tsconfig.json`â€™s `"include"` array.
* Avoid default exports inside augmentation blocks.
* Donâ€™t redeclare things from scratch; only **extend**.
* Prefix interfaces when the moduleâ€™s shape isnâ€™t guaranteed stable (`declare global { namespace JSX { ... } }` also common).

---

## ğŸ§© 4) Common real-world augmentations

**Express Request / Response**

```ts
declare module "express-serve-static-core" {
  interface Request {
    user?: User;
  }
}
```

**Next.js API Routes**

```ts
declare module "next" {
  interface NextApiRequest {
    user?: { id: string };
  }
}
```

**Jest globals**

```ts
declare global {
  namespace jest {
    interface Matchers<R> {
      toBeWithinRange(a: number, b: number): R;
    }
  }
}
```

**React JSX**

```ts
declare global {
  namespace JSX {
    interface IntrinsicElements {
      "my-widget": { label?: string };
    }
  }
}
```

---

## âš ï¸ 5) Pitfalls and safety notes

* **Donâ€™t use `declare module "*"`** unless you mean to define a catch-all fallback; it disables checking.
* **Donâ€™t duplicate** interfaces with identical property names but different types â€” merges silently overwrite and confuse IntelliSense.
* **Library updates** can break your augmentation if upstream adds the same property name with a different type.

---

## ğŸ’¬ Interview-ready answer

> Declaration merging happens when TypeScript unites multiple declarations with the same name â€” usually interfaces or namespaces.
>
> Module augmentation uses that mechanism to safely extend a third-party moduleâ€™s types.
> For example:
>
> ```ts
> import "express";
> declare module "express-serve-static-core" {
>   interface Request { user?: { id: string } }
> }
> ```
>
> That way, the compiler knows `req.user` exists everywhere, and we didnâ€™t have to fork the library.
> Itâ€™s safe as long as you *import then declare*, keep augmentations in `.d.ts` files, and avoid redefining existing properties.
> Itâ€™s a core tool for adding framework-specific context (Express, Next.js, Jest, JSX) without patching dependencies.

---

Next up is **Q18 â€“ `tsconfig` essentials** â€” thatâ€™s about strictness flags and how they shape your type-safety boundary. Want to roll into that?
