# 12. **Template literal types:** Real-world example (CSS props, event name patterns, REST endpoints).

## a

I don't know

## A

Template literal types let you build **string types from pieces**, with compile-time checking. They shine when your strings follow patterns: CSS shorthands, event names, route paths, etc. Here are practical, interview-ready patterns.

---

### 1) CSS prop families (shorthands + sides)

```ts
type Side = "top" | "right" | "bottom" | "left";
type Axis = "x" | "y";

type MarginProp =
  | "margin"
  | `margin-${Side}`
  | `margin-${Axis}`;

type CssLength = `${number}px` | `${number}rem` | `${number}em` | 0;

type Style = {
  [K in MarginProp]?: CssLength;
} & {
  [`--color-${string}`]?: string;        // custom properties
};

// ✅ OK
const s: Style = {
  margin: "8px",
  "margin-top": "1rem",
  "margin-x": 0,
  "--color-brand": "#09f",
};
// ❌ Type error: "8pt" not allowed by CssLength
```

Why it’s good: you get **autocomplete** for valid props and **rejection** of misspellings like `"margin-tpo"`.

---

### 2) Event name patterns (DOM/app events)

```ts
type DomEvent = "click" | "keydown" | "input";
type EventName = `on${Capitalize<DomEvent>}`;  // "onClick" | "onKeydown" | "onInput"

type HandlerMap = {
  [K in EventName]?: (e: Event) => void;
};

// ✅
const h: HandlerMap = {
  onClick: e => {},
  onInput: e => {},
  // onChange: ...  // ❌ not in DomEvent
};

// Namespaced app events
type Entity = "user" | "post" | "comment";
type Action = "create" | "update" | "delete";
type AppEvent = `${Entity}:${Action}`; // "user:create" | "post:update" | ...
```

Why it’s good: consistent **naming conventions** enforced by the type system.

---

### 3) REST endpoints & path params

```ts
type Id = `${number}`; // path ids as strings
type Resource = "users" | "posts" | "comments";

type IndexRoute = `/${Resource}`;
type ShowRoute = `/${Resource}/${Id}`;
type NestedRoute = `/users/${Id}/posts/${Id}`;

type ApiRoute = IndexRoute | ShowRoute | NestedRoute;

// Build helpers with constraints
function get<R extends ApiRoute>(route: R): Promise<unknown> {
  return fetch(route).then(r => r.json());
}

get("/users");           // ✅
get("/posts/42");        // ✅
get("/dogs/1");          // ❌ "dogs" not a Resource
get("/users/abc");       // ❌ Id must be numeric string
```

You can also **extract params** from a route template:

```ts
type ParamNames<S extends string> =
  S extends `${string}:${infer P}/${infer Rest}` ? P | ParamNames<Rest> :
  S extends `${string}:${infer P}` ? P :
  never;

type ExtractParams<T extends string> = {
  [K in ParamNames<T>]: string
};

type Route = "/users/:userId/posts/:postId";
type Params = ExtractParams<Route>; // { userId: string; postId: string }
```

Now a strongly-typed router:

```ts
function navigate<R extends string>(route: R, params: ExtractParams<R>) {/* ... */}
navigate("/users/:userId/posts/:postId", { userId: "1", postId: "9" }); // ✅
navigate("/users/:userId", { id: "1" }); // ❌ wrong key
```

---

### 4) Bonus quick hits you can mention

* **Redux action types**: `type ActionType = `${"user"|"post"}:${"create"|"delete"}`;`
* **GraphQL operation keys**: ``type Op = `${"Query"|"Mutation"}.${string}`;``
* **i18n keys**: ``type Key = `${"home"|"auth"}.${string}`;`` (or generate from nested objects)

---

### Pitfalls to call out briefly

* **Widening**: plain `const str = "user"` widens to `string` unless you use `as const`.
* **Distributive conditionals**: wrap in tuples to avoid unintended distribution when mixing with conditionals.
* **Performance**: very complex template types can slow the checker—keep helpers small and compose.

---

### Interview-ready sound bite

> Template literal types let me encode naming conventions into the type system. I use them to constrain CSS props (`margin-${Side}`), event names (`on${Capitalize<Event>}`), and REST routes (`/${Resource}/${Id}`). They deliver autocomplete and compile-time validation for strings that used to be typo-prone. With helpers to extract route params, I can type `navigate()` so wrong keys or malformed IDs fail at compile time.

---

Ready for **Q13: Key remapping in mapped types** (e.g., renaming/filtering keys), or want to jump to a practical like **P11 typed query-string parser/serializer** to apply these patterns?
