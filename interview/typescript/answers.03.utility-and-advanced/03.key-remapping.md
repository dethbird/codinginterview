# 13. **Key remapping in mapped types:** Why it’s powerful; show a rename or filter of keys.

## a

?

## A

Key remapping is the `as` clause inside mapped types: it lets you **change** (or **drop**) keys while you iterate them. That unlocks things like renaming, prefix/suffixing, filtering by value type, converting `snake_case`→`camelCase`, or turning a data shape into an API surface. It’s one of TS’s most “power-per-character” features.

---

### 1) Rename keys (prefix/suffix)

```ts
type Prefixed<T, P extends string> = {
  [K in keyof T as `${P}${Extract<K, string>}`]: T[K]
};

type User = { id: string; name: string };
type ApiUser = Prefixed<User, "user_">;
// { user_id: string; user_name: string }
```

### 2) Filter keys out (map to `never`)

```ts
type OnlyFunctions<T> = {
  [K in keyof T as T[K] extends (...args: any) => any ? K : never]: T[K]
};

type Mixed = { a: number; b: () => void; c: (x: string) => string };
type Fns = OnlyFunctions<Mixed>; 
// { b: () => void; c: (x: string) => string }
```

### 3) Value-based filtering (keep keys whose values match `V`)

```ts
type PickByValue<T, V> = {
  [K in keyof T as T[K] extends V ? K : never]: T[K]
};

type Env = { PORT: number; HOST: string; SECURE: boolean };
type BoolEnv = PickByValue<Env, boolean>; 
// { SECURE: boolean }
```

### 4) Transform a config → getters API (rename + change value type)

```ts
type Getters<T> = {
  [K in keyof T as `get${Capitalize<Extract<K, string>>}`]: () => T[K]
};

type Model = { id: string; active: boolean };
type API = Getters<Model>;
// { getId: () => string; getActive: () => boolean }
```

### 5) `snake_case` → `camelCase` (key remap with a helper)

```ts
type Camel<S extends string> =
  S extends `${infer H}_${infer T}` ? `${Lowercase<H>}${Capitalize<Camel<T>>}` : Lowercase<S>;

type CamelKeys<T> = {
  [K in keyof T as Camel<Extract<K, string>>]: T[K]
};

type FromAPI = { user_id: string; created_at: string };
type ToApp = CamelKeys<FromAPI>;
// { userId: string; createdAt: string }
```

### 6) Event map → handler props (rename + wrap type)

```ts
type Events = { click: MouseEvent; keydown: KeyboardEvent };

type Handlers<E> = {
  [K in keyof E as `on${Capitalize<Extract<K, string>>}`]?: (e: E[K]) => void
};

type Props = Handlers<Events>;
// { onClick?: (e: MouseEvent) => void; onKeydown?: (e: KeyboardEvent) => void }
```

### 7) Drop non-string keys (filter by key shape)

```ts
type StringKeysOnly<T> = {
  [K in keyof T as K extends string ? K : never]: T[K]
};
```

---

### Pitfalls to mention

* **Key collisions** after a rename will **merge** (last write wins in intersections). Be deliberate with prefixes/suffixes.
* Always `Extract<K, string>` (or constrain `K extends string`) when building template-literal keys; symbol/number keys don’t fit template strings.
* Very deep transformations can slow the checker—compose small helpers.

---

### Interview-ready sound bite

> Key remapping uses `as` in mapped types to rename or drop keys while iterating them. It lets me filter by value type, prefix/suffix names, convert `snake_case` to `camelCase`, or turn a data shape into a handler API (`{ click: MouseEvent } → { onClick(e): void }`). It’s powerful because it encodes naming conventions and constraints directly into the type system, eliminating a whole class of stringly-typed bugs.
