# 15. **Discriminated unions:** How to design them for exhaustive checks and ergonomics.

## a
 ...

## A

Beautiful â€” this one brings together half the TypeScript ideas weâ€™ve covered: unions, narrowing, and the `never` trick.
A **discriminated union** (also called a *tagged union* or *algebraic data type*) is the TypeScript way to make sure you handle every case of a variant type â€” cleanly, safely, and exhaustively.

---

## ðŸ§© 1) The core idea

Each member of the union has a **shared discriminant key** with a **unique literal value**.
That tag lets TypeScript automatically *narrow* the type inside each branch.

```ts
type Circle = { kind: "circle"; radius: number };
type Square = { kind: "square"; side: number };
type Triangle = { kind: "triangle"; base: number; height: number };

type Shape = Circle | Square | Triangle;
```

The shared key is `kind`.
Each possible literal value â€” `"circle" | "square" | "triangle"` â€” *discriminates* the shape.

---

## ðŸ§  2) Using it: automatic narrowing

```ts
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    case "triangle":
      return (shape.base * shape.height) / 2;
  }
}
```

Inside each case, `shape` is narrowed to its specific subtype â€” no need for `as` or runtime type checks.

---

## âœ… 3) Exhaustive checking with `never`

To guarantee youâ€™ve handled every possible variant, add a `default` branch that assigns to `never`.
If a new kind is added later, the compiler will yell at you.

```ts
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.radius ** 2;
    case "square": return shape.side ** 2;
    case "triangle": return (shape.base * shape.height) / 2;
    default:
      const _exhaustive: never = shape; // âŒ Error if kind missing
      return _exhaustive;
  }
}
```

Thatâ€™s your *compile-time safety net* â€” no forgotten branches.

---

## âš™ï¸ 4) Ergonomics tips

### a) Keep the discriminant **simple and literal**

Use a short, stable string or symbol like `type`, `kind`, or `status`.

```ts
type FetchState =
  | { type: "idle" }
  | { type: "loading" }
  | { type: "success"; data: string }
  | { type: "error"; error: Error };
```

### b) Compose with helper utilities

You can define helper constructors to reduce boilerplate:

```ts
const idle = (): FetchState => ({ type: "idle" });
const success = (data: string): FetchState => ({ type: "success", data });
```

### c) Use `as const` for object literals

Without it, TypeScript widens `"idle"` to `string`.

```ts
const state = { type: "idle" } as const; // ensures "idle" literal
```

### d) Use discriminated unions for reducers and React components

Theyâ€™re perfect for state machines:

```ts
type Action =
  | { type: "FETCH_START" }
  | { type: "FETCH_SUCCESS"; payload: string }
  | { type: "FETCH_ERROR"; error: string };

function reducer(state: FetchState, action: Action): FetchState {
  switch (action.type) {
    case "FETCH_START":   return { type: "loading" };
    case "FETCH_SUCCESS": return { type: "success", data: action.payload };
    case "FETCH_ERROR":   return { type: "error", error: new Error(action.error) };
    default:
      const _exhaustive: never = action;
      return _exhaustive;
  }
}
```

---

## ðŸ§© 5) Advanced ergonomics: narrowing helpers

Instead of `switch`, you can make tiny reusable guards:

```ts
function isKind<K extends Shape["kind"]>(
  shape: Shape,
  kind: K
): shape is Extract<Shape, { kind: K }> {
  return shape.kind === kind;
}

if (isKind(shape, "square")) {
  shape.side; // âœ… now known as Square
}
```

This patternâ€™s great for large codebases where you donâ€™t want to write switch statements everywhere.

---

## ðŸ’¬ Interview-ready answer

> Discriminated unions are unions where each member has a shared discriminant property with a unique literal value â€” for example, `{ kind: "circle" } | { kind: "square" }`.
>
> Theyâ€™re designed for safe control flow: TypeScript automatically narrows based on that tag, so you can switch on `kind` and get full intellisense for each variant.
>
> To make them ergonomic, I always mark the discriminant literal with `as const` and include a `default` branch that assigns to `never` for **exhaustive checks**.
>
> Theyâ€™re perfect for modeling finite states â€” like fetch status, UI modes, or Redux actions â€” where you want the compiler to tell you if youâ€™ve missed a case.

---

Next up: **Q16 â€“ Branded/opaque types** (how to make `UserId` â‰  `string` without runtime cost). Itâ€™s short but powerful.
