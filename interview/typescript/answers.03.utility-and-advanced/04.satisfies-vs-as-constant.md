# 14. **`satisfies` vs `as const`:** Explain each and when they’re complementary.

## a

Please help.

## A

You’re about to learn two of the most elegant—and most confusing—TypeScript operators.
They both “lock things down,” but they do it in very different ways and are often *used together*.

---

## 🧩 1) `as const` — literal freezing

`as const` **tells the compiler**:

> “Infer this value as *narrowly* as possible and make it readonly.”

So instead of widening `"red"` → `string`, it stays `"red"`.
Instead of `number[]`, you get `readonly [1, 2, 3]`.

```ts
const palette = ["red", "green", "blue"] as const;
// type: readonly ["red", "green", "blue"]

const config = { env: "prod", retries: 3 } as const;
// type: { readonly env: "prod"; readonly retries: 3 }
```

That’s perfect for:

* Creating literal unions (`palette[number]` → `"red" | "green" | "blue"`)
* Preventing accidental mutation
* Typing fixed data objects (routes, CSS maps, etc.)

Essentially:
`as const` = “turn this into compile-time constants.”

---

## 🧠 2) `satisfies` — structural validation

`satisfies` is newer (TS 4.9). It **checks that a value fits a constraint** *without widening* its type to that constraint.

Think of it as a middle ground between assignment and casting:

```ts
type Theme = {
  primary: string;
  secondary: string;
};

const theme = {
  primary: "#09f",
  secondary: "#333",
  extra: "#ccc", // still OK — type not widened
} satisfies Theme;
```

Here:

* TypeScript checks that `theme` has at least `primary` and `secondary` of type `string`.
* But `theme`’s *actual type* remains the full object with `extra`.

Compare to normal annotation:

```ts
const theme: Theme = { primary: "#09f", secondary: "#333", extra: "#ccc" };
// ❌ Error: extra not in Theme
```

Compare to `as Theme`:

```ts
const theme = { primary: 123 } as Theme;
// ✅ Compiles, but unsafe — no checking!
```

So:

* `as` **asserts** (forces, no safety)
* `satisfies` **verifies** (checks, but doesn’t erase)
* `:` **annotates** (forces *and* checks, but erases precision)

---

## ⚙️ 3) When they’re **complementary**

They work beautifully together for literal objects and arrays where you want both:

* literal *narrowness* (`as const`)
* type *validation* (`satisfies`)

Example:

```ts
const routes = {
  home: "/",
  profile: "/user/:id",
} as const satisfies Record<string, `/${string}`>;

// ✅ checked that each value starts with "/"
// ✅ still preserves literal types:
//    routes.profile: "/user/:id"
```

Another:

```ts
const COLORS = ["red", "green", "blue"] as const;

type Color = typeof COLORS[number]; // "red" | "green" | "blue"

const COLOR_CODES = {
  red: "#f00",
  green: "#0f0",
  blue: "#00f",
} as const satisfies Record<Color, string>;
// ✅ validated all keys present, ✅ values are strings
```

---

## ⚠️ 4) Gotchas

* `as const` makes everything `readonly` — if you need to mutate later, don’t over-freeze.
* `satisfies` checks structure **only at declaration**; it’s not runtime validation.
* `as const` affects **inference**; `satisfies` affects **checking**.

---

## 💬 Interview-ready answer

> `as const` freezes a literal value—TypeScript infers the most specific literal types and marks properties readonly. It’s great for constant data like enums, routes, or palettes.
>
> `satisfies` checks that a value conforms to a type without widening it to that type. It keeps literal precision and adds compile-time safety, unlike `as`, which just forces a type.
>
> They’re complementary: `as const` gives narrow literals; `satisfies` ensures those literals fit a broader shape. For example:
>
> ```ts
> const endpoints = {
>   users: "/api/users",
>   posts: "/api/posts",
> } as const satisfies Record<string, `/${string}`>;
> ```
>
> That pattern yields exact string unions *and* structural validation—safe, narrow, and readable.

---

Want to continue with **Q15 – Discriminated unions** next? It ties directly into what you’ve already seen with narrowing and template literals.
