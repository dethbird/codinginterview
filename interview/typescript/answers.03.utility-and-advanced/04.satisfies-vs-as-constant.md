# 14. **`satisfies` vs `as const`:** Explain each and when theyâ€™re complementary.

## a

Please help.

## A

Youâ€™re about to learn two of the most elegantâ€”and most confusingâ€”TypeScript operators.
They both â€œlock things down,â€ but they do it in very different ways and are often *used together*.

---

## ğŸ§© 1) `as const` â€” literal freezing

`as const` **tells the compiler**:

> â€œInfer this value as *narrowly* as possible and make it readonly.â€

So instead of widening `"red"` â†’ `string`, it stays `"red"`.
Instead of `number[]`, you get `readonly [1, 2, 3]`.

```ts
const palette = ["red", "green", "blue"] as const;
// type: readonly ["red", "green", "blue"]

const config = { env: "prod", retries: 3 } as const;
// type: { readonly env: "prod"; readonly retries: 3 }
```

Thatâ€™s perfect for:

* Creating literal unions (`palette[number]` â†’ `"red" | "green" | "blue"`)
* Preventing accidental mutation
* Typing fixed data objects (routes, CSS maps, etc.)

Essentially:
`as const` = â€œturn this into compile-time constants.â€

---

## ğŸ§  2) `satisfies` â€” structural validation

`satisfies` is newer (TS 4.9). It **checks that a value fits a constraint** *without widening* its type to that constraint.

Think of it as a middle ground between assignment and casting:

```ts
type Theme = {
  primary: string;
  secondary: string;
};

const theme = {
  primary: "#09f",
  secondary: "#333",
  extra: "#ccc", // still OK â€” type not widened
} satisfies Theme;
```

Here:

* TypeScript checks that `theme` has at least `primary` and `secondary` of type `string`.
* But `theme`â€™s *actual type* remains the full object with `extra`.

Compare to normal annotation:

```ts
const theme: Theme = { primary: "#09f", secondary: "#333", extra: "#ccc" };
// âŒ Error: extra not in Theme
```

Compare to `as Theme`:

```ts
const theme = { primary: 123 } as Theme;
// âœ… Compiles, but unsafe â€” no checking!
```

So:

* `as` **asserts** (forces, no safety)
* `satisfies` **verifies** (checks, but doesnâ€™t erase)
* `:` **annotates** (forces *and* checks, but erases precision)

---

## âš™ï¸ 3) When theyâ€™re **complementary**

They work beautifully together for literal objects and arrays where you want both:

* literal *narrowness* (`as const`)
* type *validation* (`satisfies`)

Example:

```ts
const routes = {
  home: "/",
  profile: "/user/:id",
} as const satisfies Record<string, `/${string}`>;

// âœ… checked that each value starts with "/"
// âœ… still preserves literal types:
//    routes.profile: "/user/:id"
```

Another:

```ts
const COLORS = ["red", "green", "blue"] as const;

type Color = typeof COLORS[number]; // "red" | "green" | "blue"

const COLOR_CODES = {
  red: "#f00",
  green: "#0f0",
  blue: "#00f",
} as const satisfies Record<Color, string>;
// âœ… validated all keys present, âœ… values are strings
```

---

## âš ï¸ 4) Gotchas

* `as const` makes everything `readonly` â€” if you need to mutate later, donâ€™t over-freeze.
* `satisfies` checks structure **only at declaration**; itâ€™s not runtime validation.
* `as const` affects **inference**; `satisfies` affects **checking**.

---

## ğŸ’¬ Interview-ready answer

> `as const` freezes a literal valueâ€”TypeScript infers the most specific literal types and marks properties readonly. Itâ€™s great for constant data like enums, routes, or palettes.
>
> `satisfies` checks that a value conforms to a type without widening it to that type. It keeps literal precision and adds compile-time safety, unlike `as`, which just forces a type.
>
> Theyâ€™re complementary: `as const` gives narrow literals; `satisfies` ensures those literals fit a broader shape. For example:
>
> ```ts
> const endpoints = {
>   users: "/api/users",
>   posts: "/api/posts",
> } as const satisfies Record<string, `/${string}`>;
> ```
>
> That pattern yields exact string unions *and* structural validationâ€”safe, narrow, and readable.

---

Want to continue with **Q15 â€“ Discriminated unions** next? It ties directly into what youâ€™ve already seen with narrowing and template literals.
