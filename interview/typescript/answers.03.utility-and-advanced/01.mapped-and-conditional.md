# 11. **Mapped & conditional types:** Show how to build `Writable<T>`, `NonNullableKeys<T>`, or `DeepPartial<T>`.

## a

PLease help.

## A

You got it—this is where TypeScript turns into a tiny meta-language. We’ll build each with **mapped types** (iterate over keys) and **conditional types** (choose by rule). I’ll show idiomatic, interview-ready versions plus a couple of gotchas.

---

## `Writable<T>` (remove `readonly`)

**Shallow** version (most common):

```ts
type Writable<T> = { -readonly [K in keyof T]: T[K] };
```

* `-readonly` removes the `readonly` modifier for each key.
* Works for objects, arrays, and tuples (turns `readonly [A, B]` into `[A, B]`).

**Example**

```ts
type Before = {
  readonly id: string;
  readonly coords: readonly [number, number];
};
type After = Writable<Before>;
// { id: string; coords: [number, number] }
```

> Gotcha: If you need it **deep**, define `DeepWritable<T>` and recurse like `DeepPartial` does.

---

## `NonNullableKeys<T>` (keep only keys whose values can’t be `null` or `undefined`)

We test each property against `NonNullable<T[K]>`. The `-?` removes optionality **during the check** so `optional?: X` counts as possibly `undefined`.

```ts
type NonNullableKeys<T> = {
  [K in keyof T]-?: [T[K]] extends [NonNullable<T[K]>] ? K : never
}[keyof T];
```

* The outer index (`[...] [keyof T]`) turns the mapped union of `K | never | ...` into a union of **kept keys**.
* The tuple wrapper `[T[K]]` avoids distributive conditional pitfalls.

**Example**

```ts
type Model = {
  id: string;               // keep
  name?: string;            // drop (possibly undefined)
  nickname: string | null;  // drop (possibly null)
  age: number;              // keep
};

type Keys = NonNullableKeys<Model>; // "id" | "age"
```

> Gotcha: With `exactOptionalPropertyTypes: true`, `name?: string` is treated as `string | undefined`, so it’s (correctly) excluded.

If you want to **extract a new object type** with only those keys:

```ts
type PickNonNullable<T> = Pick<T, NonNullableKeys<T>>;
```

---

## `DeepPartial<T>` (recursively optional)

Make every nested property optional, while treating arrays/tuples as collections of partial elements. Functions remain callable.

```ts
type DeepPartial<T> =
  // Leave functions alone
  T extends (...args: any[]) => any ? T
  // Arrays & tuples → partial element type
  : T extends ReadonlyArray<infer U> ? Array<DeepPartial<U>>
  // Objects → recurse per key, make optional
  : T extends object ? { [K in keyof T]?: DeepPartial<T[K]> }
  // Primitives → as is
  : T;
```

**Example**

```ts
type Config = {
  api: {
    url: string;
    headers: Record<string, string>;
  };
  features: Array<{ key: string; enabled: boolean }>;
  onError?: (e: unknown) => void;
};

type PartialConfig = DeepPartial<Config>;
/*
{
  api?: {
    url?: string;
    headers?: { [k: string]: string | undefined };
  };
  features?: { key?: string; enabled?: boolean }[];
  onError?: (e: unknown) => void; // unchanged (function)
}
*/
```

> Variations:
>
> * If you want **readonly arrays preserved** (i.e., `ReadonlyArray` in → `ReadonlyArray` out), split the array branch into `ReadonlyArray` vs `Array`.
> * If you want to support `Map/Set`, add branches:
>
>   ```ts
>   : T extends Map<infer K, infer V> ? Map<DeepPartial<K>, DeepPartial<V>>
>   : T extends Set<infer U> ? Set<DeepPartial<U>>
>   ```

---

## Quick interview notes to say out loud

* **Mapped types**: “I iterate keys with `[K in keyof T]` and can tweak modifiers like `-readonly` and `?`.”
* **Conditional types**: “I branch on relationships with `extends`; tuple wrapping `[X]` avoids distributive surprises.”
* **`exactOptionalPropertyTypes`**: “With it on, `name?: string` is truly `string | undefined`, changing filters like `NonNullableKeys`.”

---

If you want to flex this with code, pick a practical: I can review a `DeepPartial<T>` you implement and add test cases (arrays, tuples, functions, nested objects, and `exactOptionalPropertyTypes` on/off).
