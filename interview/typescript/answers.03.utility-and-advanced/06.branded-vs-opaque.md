# 16. **Branded/opaque types:** Create “UserId” vs “string” without runtime cost; why it helps.

## a

I think branding is when you add an extra `_brand` property that makes 2 types that extend the same type different. But really I need help with this one.

## A

Exactly right — that’s the seed of the idea. Branding (or “opaque typing”) is a *compile-time illusion*: we take a plain primitive like `string` or `number`, and we **disguise it with a unique tag** so that TypeScript stops treating all values of that primitive as interchangeable.

It costs **zero at runtime**, but gives **nominal-type safety** inside TypeScript’s structural world.

---

## 🧩 1) The problem it solves

TypeScript is *structurally typed*: if two types have the same shape, they’re compatible.

```ts
type User = { id: string };
type Product = { id: string };

function getUser(u: User) {}
const p: Product = { id: "P-001" };

getUser(p); // ✅ compiles (same shape) — but conceptually wrong
```

We want to tell the compiler:

> “This string is a **UserId**, not just any string.”

---

## 🧠 2) The branding pattern

Use an **intersection type** that adds a phantom field (only visible to the compiler):

```ts
type Brand<K, T> = T & { __brand: K };
```

Then define branded primitives:

```ts
type UserId = Brand<"UserId", string>;
type ProductId = Brand<"ProductId", string>;
```

Now they’re distinct:

```ts
let u: UserId = "u123" as UserId;
let p: ProductId = "p123" as ProductId;

u = p; // ❌ Type '"p123" & { __brand: "ProductId" }' not assignable to 'UserId'
```

Runtime remains a bare string, but the compiler enforces identity.

---

## ⚙️ 3) Helper factories (safe creation)

You can hide the `as` assertion behind a function to prevent arbitrary casting:

```ts
function makeUserId(id: string): UserId {
  return id as UserId;
}

function getUser(id: UserId) { /* ... */ }

const id = makeUserId("u123");
getUser(id);      // ✅
getUser("u123");  // ❌ must explicitly brand it
```

---

## 🧩 4) Variations

### a) Using `unique symbol` for the tag

```ts
declare const userBrand: unique symbol;
type UserId = string & { [userBrand]: true };
```

Each `unique symbol` makes a one-of-a-kind property — guaranteed unique even across modules.

### b) Using interfaces for ergonomics

```ts
interface UserId extends String { readonly __brand: "UserId"; }
```

Syntactic sugar; works the same way.

---

## ✅ 5) Why it helps

1. **Prevents mixing of semantically different IDs**

   * You can’t pass a `ProductId` to a function expecting `UserId`.
2. **Adds meaning to primitives**
   Makes code self-documenting (`UserId` > `string`).
3. **No runtime cost**
   The tag disappears after compilation.
4. **Safer API boundaries**
   Especially useful when IDs or codes share type but not domain.
5. **Gradual typing**
   You can introduce branding incrementally to tighten critical code paths.

---

## 🧩 6) Common use cases

* Entity IDs (`UserId`, `OrderId`, `ProductId`)
* Currency units (`USD`, `EUR`)
* Distinguishing internal vs external data (`ExternalId`, `InternalId`)
* Guards in domain-driven design layers.

---

## 💬 Interview-ready answer

> Branding (or opaque typing) creates distinct compile-time identities for values that would otherwise share the same structure.
>
> For example:
>
> ```ts
> type Brand<K, T> = T & { __brand: K };
> type UserId = Brand<"UserId", string>;
> ```
>
> Now a `UserId` can’t be accidentally passed where a plain `string` or a `ProductId` is expected.
> It’s purely a compile-time construct—no runtime overhead—and it enforces domain-level distinctions inside TypeScript’s structural type system.
> This prevents category errors like mixing entity IDs or currency units while keeping the runtime zero-cost.

---

Next up: **Q17 – Declaration merging & module augmentation** (how to safely extend third-party types). Want to keep going?
