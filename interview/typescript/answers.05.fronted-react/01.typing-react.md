# 22. **Typing React props/state/hooks:** Patterns for `useState`, `useRef`, `useReducer` with discriminated actions.

## a

## A

Excellent ‚Äî this is where TypeScript meets React, and where you can show you understand both **type inference** and **ergonomics**.
Interviewers love asking this because it reveals how well you handle generics, state, and events in everyday React work.

---

## üß© 1) Typing props (the foundation)

Simplest case:

```tsx
type ButtonProps = {
  label: string;
  disabled?: boolean;
  onClick?: () => void;
};

export function Button({ label, disabled, onClick }: ButtonProps) {
  return <button disabled={disabled} onClick={onClick}>{label}</button>;
}
```

TypeScript infers everything automatically from `ButtonProps`.
If you pass the wrong prop name, you get instant feedback.

---

### a) Using `React.FC` (or not)

You‚Äôll see both patterns:

```tsx
const Button: React.FC<ButtonProps> = ({ label }) => <button>{label}</button>;
```

But modern TS/React style **avoids `React.FC`** because:

* It makes `children` always optional, even if you didn‚Äôt include it.
* It can erase generic inference on props.

So prefer plain function declarations or `React.ComponentType<Props>` when needed.

---

## üß† 2) Typing state hooks

### a) Simple

```tsx
const [count, setCount] = useState(0); // inferred as number
```

### b) Complex initial state (use generic)

```tsx
type User = { id: string; name: string } | null;
const [user, setUser] = useState<User>(null);
```

If the initial value doesn‚Äôt allow inference, supply `<User>` explicitly.

---

## ‚öôÔ∏è 3) Typing `useRef`

```tsx
const inputRef = useRef<HTMLInputElement>(null);

// safe access pattern
if (inputRef.current) inputRef.current.focus();
```

If you‚Äôre storing *non-DOM* data, use a generic ref:

```tsx
const idRef = useRef<string | null>(null);
```

---

## üß© 4) Typing `useReducer` (discriminated union example)

```tsx
type Action =
  | { type: "INCREMENT" }
  | { type: "SET"; payload: number };

function reducer(state: number, action: Action): number {
  switch (action.type) {
    case "INCREMENT": return state + 1;
    case "SET": return action.payload;
    default:
      const _exhaustive: never = action; // ensure all handled
      return _exhaustive;
  }
}

const [count, dispatch] = useReducer(reducer, 0);
```

---

## ‚öôÔ∏è 5) Typing events (DOM specifics)

React wraps DOM events in synthetic event types.

```tsx
function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
  console.log(e.target.value);
}

function handleClick(e: React.MouseEvent<HTMLButtonElement>) {
  console.log(e.currentTarget);
}
```

Pattern: `React.[EventType]<HTML element type>`
Common ones:

* `ChangeEvent`
* `MouseEvent`
* `KeyboardEvent`
* `FormEvent`

---

## üß© 6) Typing custom hooks

```tsx
function useLocalStorage<T>(key: string, initial: T) {
  const [value, setValue] = useState<T>(() => {
    const stored = localStorage.getItem(key);
    return stored ? (JSON.parse(stored) as T) : initial;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}

const [theme, setTheme] = useLocalStorage("theme", "light"); // T = string
```

Notice the `<T>` generic and `as const` on return tuple for read-only `[value, setValue]`.

---

## ‚öôÔ∏è 7) Typing context safely

```tsx
const ThemeContext = React.createContext<string | null>(null);

function useTheme() {
  const ctx = React.useContext(ThemeContext);
  if (!ctx) throw new Error("useTheme must be inside ThemeProvider");
  return ctx;
}
```

Or use a generic helper to avoid repeating null checks:

```tsx
function createSafeContext<T>() {
  const Ctx = React.createContext<T | undefined>(undefined);
  const useCtx = () => {
    const c = React.useContext(Ctx);
    if (c === undefined)
      throw new Error("Context used outside provider");
    return c;
  };
  return [Ctx.Provider, useCtx] as const;
}

const [ThemeProvider, useTheme] = createSafeContext<string>();
```

---

## üí° 8) Typing reusable generic components

Example: typed `<Select<Option>>`

```tsx
type OptionShape = { label: string; value: string };

function Select<T extends OptionShape>({
  options,
  getLabel = o => o.label,
  onChange,
}: {
  options: T[];
  getLabel?: (o: T) => string;
  onChange: (o: T) => void;
}) {
  return (
    <select onChange={e => onChange(options[e.target.selectedIndex])}>
      {options.map(o => (
        <option key={o.value}>{getLabel(o)}</option>
      ))}
    </select>
  );
}
```

Usage:

```tsx
<Select
  options={[{ label: "Dog", value: "dog" }, { label: "Cat", value: "cat" }]}
  onChange={o => console.log(o.value)}
/>
```

Generic props let TS infer `T` automatically.

---

## ‚úÖ 9) Common pitfalls

* Forgetting `<T>` on `useState` or `useReducer` ‚Üí TS infers `any`.
* Using `React.FC` on generic components ‚Üí kills inference.
* Over-narrowing state types ‚Üí makes `setState` awkward.
* Missing `React.` prefix for event types ‚Üí fallback to DOM `Event` (less specific).

---

## üí¨ Interview-ready answer

> In React with TypeScript, I define props using plain object types instead of `React.FC` for better inference.
> I use generic parameters with hooks like `useState<T>()` or `useReducer` for complex states, and the built-in event types like `React.ChangeEvent<HTMLInputElement>` for handlers.
>
> For context and reusable components, I rely on generics ‚Äî for example, a `createSafeContext<T>()` helper that ensures the context is never `undefined`.
> The goal is to type props and hooks strongly but ergonomically, so inference does most of the work for you.

---

Next up: **Q23 ‚Äì Context & generics** (deeper dive into safe, reusable `createContext` patterns). Continue?
