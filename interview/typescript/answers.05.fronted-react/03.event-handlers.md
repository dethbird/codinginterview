# 24. **Event handlers & DOM types:** Correctly typing `onChange`, `onClick`, and custom DOM events.

## a

## A

Perfect ‚Äî this one is both practical and sneaky: it looks trivial (‚Äújust use `onClick`!‚Äù), but strong handling of DOM event types in TypeScript is one of the cleanest ways to show mastery of **React‚Äôs synthetic events** and **TypeScript‚Äôs generic inference**.

Let‚Äôs unpack the moving parts.

---

## üß© 1) React‚Äôs Synthetic Events

React wraps native browser events in its own generic type:
`React.SyntheticEvent<T, E>` ‚Äî where:

* `T` = the element type (`HTMLInputElement`, `HTMLButtonElement`, etc.)
* `E` = the underlying browser event (`MouseEvent`, `ChangeEvent`, etc.)

All React event types extend this generic.

### Common ones:

| Event Type                              | Element Type          | Typical usage    |
| --------------------------------------- | --------------------- | ---------------- |
| `React.MouseEvent<HTMLButtonElement>`   | button clicks         | onClick          |
| `React.ChangeEvent<HTMLInputElement>`   | input text            | onChange         |
| `React.FormEvent<HTMLFormElement>`      | form submits          | onSubmit         |
| `React.KeyboardEvent<HTMLInputElement>` | keyboard interactions | onKeyDown        |
| `React.FocusEvent<HTMLInputElement>`    | focus/blur            | onFocus / onBlur |

---

## üß† 2) Typing handlers directly

```tsx
function handleClick(e: React.MouseEvent<HTMLButtonElement>) {
  console.log("clicked", e.currentTarget.value);
}

function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
  console.log("input value:", e.target.value);
}
```

### Why use the `<HTML...>` generic?

Because without it, `e.target` and `e.currentTarget` default to `EventTarget`, which has no `.value`.

---

## ‚öôÔ∏è 3) Inline handlers in JSX (inference happens automatically)

```tsx
export function LoginForm() {
  return (
    <form
      onSubmit={e => {
        e.preventDefault(); // e: React.FormEvent<HTMLFormElement>
      }}
    >
      <input
        onChange={e => console.log(e.target.value)} // e: React.ChangeEvent<HTMLInputElement>
      />
    </form>
  );
}
```

TypeScript infers the correct event type based on the JSX tag, so you rarely need to annotate inline handlers.

---

## üß© 4) Custom handler props

When you define a component that *accepts* event handlers, type them precisely.

```tsx
type InputProps = {
  label: string;
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
};

export function Input({ label, onChange }: InputProps) {
  return (
    <label>
      {label}
      <input onChange={onChange} />
    </label>
  );
}
```

This allows:

```tsx
<Input label="Name" onChange={e => console.log(e.target.value)} />;
```

If you want to make it generic over element type:

```tsx
type ChangeHandler<T extends HTMLElement> = React.ChangeEventHandler<T>;
```

Now you can do:

```tsx
const handleSelect: ChangeHandler<HTMLSelectElement> = e => console.log(e.target.value);
```

---

## ‚öôÔ∏è 5) Custom event creation

React‚Äôs synthetic system doesn‚Äôt support arbitrary event types.
But for DOM APIs like `window.addEventListener`, use **native** event types:

```tsx
window.addEventListener("keydown", (e: KeyboardEvent) => {
  console.log(e.key);
});
```

Note the difference:

* `KeyboardEvent` ‚Üí **browser native**
* `React.KeyboardEvent` ‚Üí **inside React elements**

So in a React component:

```tsx
<input onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => console.log(e.key)} />;
```

Outside React (plain DOM listener):

```ts
document.addEventListener("keydown", (e: KeyboardEvent) => console.log(e.key));
```

---

## üß© 6) Event typing with generics

Useful for reusable utilities:

```tsx
function withPreventDefault<T extends HTMLElement>(
  handler: (e: React.SyntheticEvent<T>) => void
) {
  return (e: React.SyntheticEvent<T>) => {
    e.preventDefault();
    handler(e);
  };
}

<button onClick={withPreventDefault(e => console.log(e.currentTarget))}>Click</button>;
```

---

## ‚ö†Ô∏è 7) Common pitfalls

* **Forgetting `React.` prefix** ‚Üí uses the DOM `Event`, which lacks correct props.
* **Using `any` for handlers** ‚Üí loses inference entirely.
* **Confusing `target` and `currentTarget`** ‚Üí in React, `currentTarget` is strongly typed; `target` may vary.
* **Adding listeners directly to elements inside React** (`ref.current.addEventListener`) ‚Üí use native `Event` types there.

---

## ‚úÖ 8) Real-world example: reusable input component

```tsx
type TextInputProps = {
  value: string;
  onValueChange: (value: string) => void;
};

export function TextInput({ value, onValueChange }: TextInputProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) =>
    onValueChange(e.target.value);

  return <input value={value} onChange={handleChange} />;
}
```

You expose a clean handler (`onValueChange`) while keeping internal details strongly typed.

---

## üí¨ Interview-ready answer

> React wraps native DOM events with its own synthetic event types. I use the appropriate generic like `React.ChangeEvent<HTMLInputElement>` or `React.MouseEvent<HTMLButtonElement>` to ensure `target.value` and `currentTarget` are correctly typed.
>
> Inline JSX handlers are inferred automatically, but when I define reusable components, I explicitly type their handler props ‚Äî often with `React.ChangeEventHandler<T>` or `React.MouseEventHandler<T>`.
>
> Inside React I use `React.*` events; for direct DOM listeners via `addEventListener`, I use native browser `Event` types. Knowing that distinction prevents a lot of confusion between the two systems.

---

Next up: **Q25 ‚Äì Typing custom hooks that return multiple values or functions**, including patterns for tuples and function overloads. Continue?
