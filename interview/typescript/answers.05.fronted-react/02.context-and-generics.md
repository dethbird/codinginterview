# 23. **Context & generics:** Type a Context that‚Äôs safe pre-provider and supports generics.

## a

## A

Perfect ‚Äî this is the natural extension of the previous one, and it‚Äôs a great ‚Äúsenior-signal‚Äù question. Most React engineers can type props; only the more experienced can explain how to make a **generic context** that‚Äôs both safe and ergonomic.

Let‚Äôs break it down.

---

## üß© 1) The problem

React‚Äôs built-in `createContext` is *unsafe by default*:

```tsx
const ThemeContext = React.createContext<string | null>(null);

function useTheme() {
  const theme = React.useContext(ThemeContext);
  // theme: string | null ‚ùóÔ∏è
  if (!theme) throw new Error("No provider found!");
  return theme;
}
```

You have to handle `null` manually everywhere or add a custom hook guard.
It‚Äôs easy to forget ‚Äî which defeats the purpose of strong typing.

We can fix that with **generics** and **a safe factory**.

---

## ‚öôÔ∏è 2) The generic `createSafeContext` pattern

We define a helper that:

1. Creates a context typed as `T | undefined`.
2. Returns both the `Provider` and a `useContext` hook that throws if used outside the provider.
3. Infers `T` automatically.

```tsx
import React from "react";

function createSafeContext<T>() {
  const Ctx = React.createContext<T | undefined>(undefined);

  function useCtx() {
    const c = React.useContext(Ctx);
    if (c === undefined) {
      throw new Error("useCtx must be used inside its Provider");
    }
    return c;
  }

  return [Ctx.Provider, useCtx] as const;
}
```

### Usage:

```tsx
// Step 1: Create provider + hook
const [ThemeProvider, useTheme] = createSafeContext<string>();

// Step 2: Provide value
<ThemeProvider value="dark">
  <App />
</ThemeProvider>;

// Step 3: Use safely anywhere
const theme = useTheme(); // theme: string ‚úÖ never undefined
```

The generic `T` ensures whatever value you pass to the provider will be the same type you get back from `useTheme()`.

---

## üß† 3) Real-world variations

### a) Context for complex objects

```tsx
type AuthContext = { user: User; logout: () => void };
const [AuthProvider, useAuth] = createSafeContext<AuthContext>();

useAuth().user.name; // ‚úÖ typed
```

### b) Context with default fallback (no throw)

Sometimes you do want a default value.
Then you can make it optional:

```tsx
function createDefaultContext<T>(defaultValue: T) {
  const Ctx = React.createContext<T>(defaultValue);
  return [Ctx.Provider, () => React.useContext(Ctx)] as const;
}
```

### c) Context that depends on generics downstream

For reusable component libraries, you can parameterize the hook itself:

```tsx
function createDataContext<T>() {
  const Ctx = React.createContext<T | null>(null);
  const useData = () => {
    const ctx = React.useContext(Ctx);
    if (!ctx) throw new Error("No data context");
    return ctx;
  };
  return { Ctx, useData };
}

// Later
type User = { id: string; name: string };
const { Ctx: UserCtx, useData: useUser } = createDataContext<User>();
```

This lets teams share one generic pattern across contexts.

---

## ‚ö†Ô∏è 4) Common pitfalls

* **Don‚Äôt default `createContext` to an empty object `{}`.** That lies to the type system and masks missing providers.
* **Don‚Äôt use `React.FC` for the provider component** if it prevents generic inference.
* **Remember to use `as const`** when returning the tuple to keep types literal and tuple-shaped.
* If you‚Äôre authoring a library, mark the helper `export function createSafeContext<T>()` ‚Äî inference will work across modules.

---

## ‚úÖ 5) Why this is senior-level

* You‚Äôre showing you understand **context‚Äôs runtime behavior** and **TypeScript‚Äôs type-safety boundaries.**
* You can articulate how to build reusable generic utilities for others.
* It demonstrates *both* conceptual rigor (runtime safety) and developer ergonomics.

---

## üí¨ Interview-ready answer

> React‚Äôs `createContext` is untyped by default and allows `undefined` values, so I like to wrap it in a generic helper.
>
> ```ts
> function createSafeContext<T>() {
>   const Ctx = React.createContext<T | undefined>(undefined);
>   const useCtx = () => {
>     const c = React.useContext(Ctx);
>     if (c === undefined)
>       throw new Error("Context used outside provider");
>     return c;
>   };
>   return [Ctx.Provider, useCtx] as const;
> }
> ```
>
> This way I can write `const [AuthProvider, useAuth] = createSafeContext<Auth>()`, and anywhere I call `useAuth()` I get a fully typed, non-nullable value.
> It‚Äôs a pattern that balances runtime safety and strong type inference for reusable context hooks.

---

Next in the series would be **Q24 ‚Äì Event handlers & DOM types**, which connects directly to typing `onChange`, `onClick`, and custom DOM events. Shall we keep going?
