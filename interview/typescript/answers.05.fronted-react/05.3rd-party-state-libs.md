# 26. **Third-party state libs:** Typing Redux Toolkit slices/thunks or TanStack Query hooks cleanly.

## a

## A

Letâ€™s make you dangerous with two patterns interviewers actually care about: **Redux Toolkit (RTK) with thunks/RTK Query** and **TanStack Query**. The goal is *clean types that stay inferred*, not ceremony.

---

# Redux Toolkit: slices, thunks, selectors

## 1) Project-wide types (do this once)

```ts
// store.ts
import { configureStore } from "@reduxjs/toolkit";
import user from "./user.slice";

export const store = configureStore({ reducer: { user } });

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// typed hooks
import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

## 2) Slice with inferred action payloads

```ts
// user.slice.ts
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

type User = { id: string; name: string } | null;
type State = { current: User; status: "idle"|"loading"|"error" };

const initial: State = { current: null, status: "idle" };

const user = createSlice({
  name: "user",
  initialState: initial,
  reducers: {
    set(state, action: PayloadAction<User>) { state.current = action.payload; },
    setStatus(state, action: PayloadAction<State["status"]>) { state.status = action.payload; }
  }
});

export const { set, setStatus } = user.actions;
export default user.reducer;
```

Immer handles mutation under the hood; `PayloadAction<T>` keeps payload typed.

## 3) Typed thunks (createAsyncThunk)

```ts
// user.thunks.ts
import { createAsyncThunk } from "@reduxjs/toolkit";
import type { RootState } from "./store";

// ReturnType, Arg, ThunkApiConfig
export const fetchUser = createAsyncThunk<
  { id: string; name: string },     // returned data
  { id: string },                    // argument
  { state: RootState; rejectValue: string }
>("user/fetch", async ({ id }, { rejectWithValue }) => {
  const res = await fetch(`/api/users/${id}`);
  if (!res.ok) return rejectWithValue("Failed to load");
  return (await res.json()) as { id: string; name: string };
});
```

Handle it in `extraReducers` with full inference:

```ts
// inside createSlice(...)
extraReducers: (b) => {
  b.addCase(fetchUser.pending, (s) => { s.status = "loading"; });
  b.addCase(fetchUser.fulfilled, (s, a) => { s.current = a.payload; s.status = "idle"; });
  b.addCase(fetchUser.rejected, (s, a) => { s.status = "error"; });
}
```

## 4) Selectors (typed and memoized)

```ts
// user.selectors.ts
import { createSelector } from "@reduxjs/toolkit";
import type { RootState } from "./store";

export const selectUser = (s: RootState) => s.user.current;
export const selectName = createSelector(selectUser, u => u?.name ?? "");
```

## 5) RTK Query (if you use it)

```ts
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

type User = { id: string; name: string };

export const api = createApi({
  reducerPath: "api",
  baseQuery: fetchBaseQuery({ baseUrl: "/api" }),
  endpoints: (b) => ({
    getUser: b.query<User, string>({ query: (id) => `/users/${id}` }),
    updateUser: b.mutation<User, Partial<User> & { id: string }>({
      query: ({ id, ...rest }) => ({ url: `/users/${id}`, method: "PATCH", body: rest })
    })
  })
});

export const { useGetUserQuery, useUpdateUserMutation } = api;
```

Wire `api.reducer` and `api.middleware` into the store once. Call sites get **inferred** `data`, `error`, `isLoading`.

---

# TanStack Query: infer from fetchers, not from thin air

## 1) Infer `TData` from the query function automatically

```ts
// fetchers.ts
export async function fetchUser(id: string) {
  const res = await fetch(`/api/users/${id}`);
  if (!res.ok) throw new Error("Failed");
  return (await res.json()) as { id: string; name: string };
}
```

```ts
// component.tsx
import { useQuery, queryOptions } from "@tanstack/react-query";
import { fetchUser } from "./fetchers";

const userQuery = (id: string) =>
  queryOptions({
    queryKey: ["user", id] as const,
    queryFn: () => fetchUser(id) // ðŸ‘ˆ TData inferred from function return
  });

function Profile({ id }: { id: string }) {
  const { data } = useQuery(userQuery(id));
  // data: { id: string; name: string } | undefined
  return <div>{data?.name}</div>;
}
```

## 2) Strong queryKey typing with `satisfies`

```ts
const qk = ["user", "byId"] as const satisfies Readonly<[string, string]>;
```

## 3) Input/Output schemas (runtime + TS via Zod)

```ts
import { z } from "zod";
const User = z.object({ id: z.string(), name: z.string() });
type User = z.infer<typeof User>;

async function fetchUserSafe(id: string): Promise<User> {
  const data = await (await fetch(`/api/users/${id}`)).json();
  return User.parse(data); // runtime check
}

useQuery({
  queryKey: ["user", id] as const,
  queryFn: () => fetchUserSafe(id) // TData=User
});
```

## 4) Mutations typed cleanly

```ts
type UpdateUserInput = { id: string; name?: string };

function useUpdateUser() {
  return useMutation({
    mutationFn: async (input: UpdateUserInput) => {
      const res = await fetch(`/api/users/${input.id}`, {
        method: "PATCH", headers: { "Content-Type": "application/json" },
        body: JSON.stringify(input)
      });
      if (!res.ok) throw new Error("Update failed");
      return (await res.json()) as { id: string; name: string };
    }
  });
}
```

## 5) Error typing (treat unknown as unknown)

React Query surfaces `error: unknown`. Narrow at the call site:

```ts
const { error } = useQuery(...);
const message = error instanceof Error ? error.message : "Unknown error";
```

---

# When to pick which (talk track)

* **RTK + RTK Query**: great if you want a unified Redux store, normalized cache, and co-located mutations/queries with auto-generated hooks.
* **TanStack Query**: best-in-class for server-state only; keeps client state minimal and avoids Redux unless you truly need global client state or reducers.

---

# Interview-ready sound bite

> I keep Redux types minimal and inferred: `RootState`, `AppDispatch`, typed hooks, and `createAsyncThunk` with `<Returned, Arg, { state; rejectValue }>` so reducers get strongly typed payloads. For server state I prefer TanStack Query and infer `TData` from the fetcher functionâ€”optionally validating with Zod so runtime and compile-time stay in sync.
>
> In both setups I avoid manual generics at call sites: properly typed fetchers, `queryOptions` with `satisfies` for `queryKey`, and slice actions with `PayloadAction<T>` give me end-to-end inference and cleaner code.

---

Want to keep rolling with the **Node/Full-stack** items (Q27â€“Q30), or jump to a **practical** now (e.g., P10 `fetchJson<T>` with Zod; P12 typed Pub/Sub bus)?
