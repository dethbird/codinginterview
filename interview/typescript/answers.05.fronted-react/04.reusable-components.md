# 25. **Reusable components with generics:** e.g., a typed `<Select<Option>>` with value/label inference.

## a

## A

Ah, yes ‚Äî this one‚Äôs the sweet spot for mid-to-senior React engineers: typing reusable **generic components** so they infer their types automatically without callers having to spell them out.
This shows that you not only understand *TypeScript generics*, but can design APIs that feel like JavaScript while giving compile-time safety.

Let‚Äôs dig in.

---

## üß© 1) The problem

You want a `<Select>` that can handle **any kind of option shape**:

```tsx
<Select
  options={[
    { value: "dog", label: "Dog" },
    { value: "cat", label: "Cat" }
  ]}
  onChange={option => console.log(option.value)}
/>
```

TypeScript should infer that `option` has `{ value: string; label: string }`.
If later you pass an array of `{ id: number; name: string }`, it should infer those keys instead.

---

## ‚öôÔ∏è 2) Basic generic pattern

We‚Äôll start with a generic parameter `T`, representing the option type.

```tsx
type SelectProps<T> = {
  options: readonly T[];
  getLabel?: (option: T) => string;
  getValue?: (option: T) => string | number;
  onChange: (option: T) => void;
};
```

Now define the component:

```tsx
function Select<T>({
  options,
  getLabel = (o => String((o as any).label)) as (o: T) => string,
  getValue = (o => String((o as any).value)) as (o: T) => string | number,
  onChange
}: SelectProps<T>) {
  return (
    <select
      onChange={e => {
        const opt = options.find(o => getValue(o) === e.target.value);
        if (opt) onChange(opt);
      }}
    >
      {options.map(o => (
        <option key={String(getValue(o))} value={String(getValue(o))}>
          {getLabel(o)}
        </option>
      ))}
    </select>
  );
}
```

---

## üß† 3) Inference magic

When you call it:

```tsx
<Select
  options={[
    { value: "dog", label: "Dog" },
    { value: "cat", label: "Cat" }
  ]}
  onChange={o => console.log(o.value)} // ‚úÖ o inferred as { value: string; label: string }
 />;
```

No `<T>` required ‚Äî the compiler infers `T` from the `options` array.

If you use a different shape:

```tsx
<Select
  options={[
    { id: 1, name: "Cher" },
    { id: 2, name: "Beastie" }
  ]}
  getLabel={o => o.name}
  getValue={o => o.id}
  onChange={o => console.log(o.id)} // ‚úÖ T inferred automatically
/>
```

Beautiful inference, full autocompletion.

---

## ‚öôÔ∏è 4) Making it stricter with constraints

If you *usually* expect a `{ label; value }` shape, constrain `T` but keep it extensible:

```tsx
type OptionLike = { label: string; value: string | number };

function Select<T extends OptionLike>({
  options,
  onChange
}: {
  options: readonly T[];
  onChange: (option: T) => void;
}) {
  return (
    <select
      onChange={e =>
        onChange(options.find(o => o.value === e.target.value)!)
      }
    >
      {options.map(o => (
        <option key={o.value}>{o.label}</option>
      ))}
    </select>
  );
}
```

This keeps the ergonomic default while still supporting `T` extensions (e.g., `{ label; value; color }`).

---

## üß© 5) Stronger `onChange` value typing

You can expose a second prop `onValueChange` that extracts the primitive `value` type:

```tsx
type SelectProps<T extends { value: V }, V = T["value"]> = {
  options: readonly T[];
  onChange?: (option: T) => void;
  onValueChange?: (value: V) => void;
};

function Select<T extends { value: V }, V = T["value"]>({
  options,
  onChange,
  onValueChange
}: SelectProps<T, V>) {
  return (
    <select
      onChange={e => {
        const opt = options.find(o => String(o.value) === e.target.value);
        if (opt) {
          onChange?.(opt);
          onValueChange?.(opt.value);
        }
      }}
    >
      {options.map(o => (
        <option key={String(o.value)} value={String(o.value)}>
          {(o as any).label}
        </option>
      ))}
    </select>
  );
}
```

Usage:

```tsx
<Select
  options={[
    { label: "Dog", value: "dog" },
    { label: "Cat", value: "cat" }
  ]}
  onValueChange={v => console.log(v.toUpperCase())} // v: string
/>
```

---

## ‚ö†Ô∏è 6) Common pitfalls

* Forgetting to mark `options` as `readonly T[]` ‚Üí breaks inference for literal arrays.
* Using `React.FC` ‚Üí kills generic inference (because React.FC erases generic params).
* Forgetting to return `as const` when defining literal options ‚Üí widens strings.

```tsx
const OPTIONS = [
  { value: "dog", label: "Dog" },
  { value: "cat", label: "Cat" }
] as const;
```

Then `options[number]["value"]` becomes `"dog" | "cat"`.

---

## ‚úÖ 7) Real-world bonus: controlled form integration

If you integrate with React Hook Form or Formik, you can type the `onChange` callback generically and infer form value types automatically.
This pattern scales across your component library ‚Äî typed inputs, selects, toggles, etc., all generic over the shape of the ‚Äúoption‚Äù or ‚Äúfield value.‚Äù

---

## üí¨ Interview-ready answer

> I design reusable generic components like `<Select<T>>` so that the option type is inferred from the props.
> For example:
>
> ```ts
> function Select<T>({ options, onChange }: { options: T[]; onChange: (o: T) => void }) { ... }
> ```
>
> Then calling `<Select options={[{ label, value }]} onChange={o => o.value}>` infers `T` automatically.
> If the options follow a `{label, value}` convention, I add `T extends { label: string; value: string | number }` to keep it constrained.
>
> The goal is to expose a clean ergonomic API while retaining full type inference ‚Äî no need for explicit `<T>` when calling it.

---

Next: **Q26 ‚Äì Advanced inference & conditional props (mutually exclusive props, overload-like patterns)** ‚Äî would you like to continue into that one?
