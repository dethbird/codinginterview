# 21. **Source of truth:** Types vs runtime validation (Zod/Valibot/typia). Where to put boundaries.

## a

## A

Perfect ‚Äî this one is philosophical *and* practical. Interviewers love it because it probes whether you understand that **TypeScript‚Äôs types disappear at runtime**, so you still need guards if real-world data is messy.

Let‚Äôs explore when your **source of truth** should be TypeScript types vs runtime validation.

---

## üß© 1) The fundamental divide

| Layer                                             | Purpose                                          | When enforced            |
| ------------------------------------------------- | ------------------------------------------------ | ------------------------ |
| **TypeScript types**                              | Compile-time guarantees; shape of code you write | Compile-time only        |
| **Runtime validation** (Zod, Valibot, io-ts, Yup) | Data validation; user input, APIs, configs       | During program execution |

TypeScript ensures internal *consistency* between modules.
But it cannot protect you from **external input** ‚Äî anything that crosses a runtime boundary (network, filesystem, environment variables, user input).

---

## üß† 2) Rule of thumb: trust inside, verify outside

* **Inside your codebase:** TS types are the single source of truth.
  Example: your functions, classes, and React components ‚Äî data never leaves memory, so the compiler guarantees safety.

* **At the boundaries:** runtime validation libraries ensure data *actually matches* those types.
  Example: request payloads, JSON config files, or database rows.

```ts
type User = { id: string; name: string };

function handleUser(user: User) {
  console.log(user.name.toUpperCase());
}

handleUser(JSON.parse('{"id":42,"name":"Cher"}')); // üò¨ runtime blow-up
```

That‚Äôs why you pair runtime validation with your static types.

---

## ‚öôÔ∏è 3) Using Zod (or similar) as the single source of truth

```ts
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
});

// üîí runtime validation
const parsed = UserSchema.parse(JSON.parse(input));

// üîÅ derive TS type automatically
type User = z.infer<typeof UserSchema>;
```

**Benefits**

* Runtime check + static type always match.
* If you update the schema, the TS type updates too.
* Eliminates ‚Äúdual maintenance‚Äù between schema and interface.

---

## üß© 4) Alternative libraries

| Library                    | Notes                                                                                     |
| -------------------------- | ----------------------------------------------------------------------------------------- |
| **Zod**                    | Most popular, ergonomic, works in browser and Node                                        |
| **Valibot**                | Smaller, faster runtime                                                                   |
| **io-ts**                  | FP-style, functional composition via `Either`                                             |
| **runtypes / superstruct** | Lightweight, good for small projects                                                      |
| **typia**                  | Generates runtime validators from existing TS types via compiler transform (experimental) |

---

## üß† 5) When to let types *drive* vs when runtime *drives*

### Type-driven (types first)

You write types/interfaces, then use them for autocompletion and inference.
Runtime layer might just do lightweight JSON schema checks.

**Use when:**

* You control both producer and consumer (internal APIs, libraries).
* Runtime data is trusted (internal service-to-service).

### Runtime-driven (schema first)

You write a runtime schema (`z.object()`), and extract types from it.

**Use when:**

* Data crosses trust boundaries (web APIs, user input).
* Validation rules matter as much as typing.

---

## ‚öñÔ∏è 6) The hybrid ‚Äúboundary layer‚Äù pattern

Validate once at the edge, then trust your types inside.

```ts
// /routes/users.ts
import { z } from "zod";

const CreateUser = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

type CreateUser = z.infer<typeof CreateUser>;

app.post("/users", (req, res) => {
  const parsed = CreateUser.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);
  
  // from here on, it's pure TypeScript safety
  const user: CreateUser = parsed.data;
  saveUser(user);
});
```

Now you get:

* runtime safety (validation)
* compile-time inference (autocompletion, refactors)
* one source of truth

---

## ‚ö†Ô∏è 7) Anti-patterns

* **Using `as Type` on untrusted data** ‚Äî disables safety.
* **Keeping separate `.ts` types and `.json` schemas** without tooling to sync.
* **Double parsing** ‚Äî validate once, then rely on types.
* **Skipping validation because ‚Äúthe API should send correct data‚Äù** ‚Äî famous last words.

---

## üí¨ Interview-ready answer

> TypeScript types exist only at compile time; they can‚Äôt protect you from bad runtime data.
> So I treat types as the source of truth *inside* the codebase, but validate everything that crosses the runtime boundary ‚Äî API payloads, user input, env vars ‚Äî with a library like Zod or Valibot.
>
> I usually define a Zod schema, infer its TypeScript type with `z.infer<typeof Schema>`, and use that both for validation and static typing. That keeps the runtime and compile-time definitions in sync and avoids ‚Äútype drift.‚Äù
>
> In short: **types for trust, schemas for truth.**

---

Next up: **Q22 ‚Äì Typing React props/state/hooks**, where we‚Äôll get practical again. Continue?
