# 20. **Performance & compile-time:** Techniques for taming slow type computation or huge monorepos.

## a

## A

Excellent — this one’s very real-world. Every big TS codebase eventually hits the “why is `tsc --noEmit` taking 90 seconds” wall.
Performance tuning in TypeScript is about knowing *where* the compiler spends time — and choosing the right balance between type safety, complexity, and incremental builds.

Let’s break it into three layers: **project structure**, **config flags**, and **type-design hygiene.**

---

## 🧩 1) Project structure — don’t let the compiler re-type the world

### a) Split your code into projects (`composite` + `references`)

A single `tsconfig` that covers hundreds of files grows quadratically in type-checking cost.
Break it into multiple “programs” that depend on each other:

```
packages/
 ├─ api/
 │   └─ tsconfig.json  { "composite": true }
 ├─ ui/
 │   └─ tsconfig.json  { "composite": true, "references": [{ "path": "../api" }] }
 └─ tsconfig.json       { "files": [], "references": [...] }
```

Then use:

```bash
tsc -b
```

The build mode only re-checks changed packages and caches `.tsbuildinfo`.

### b) Use `exclude` and `include` wisely

Don’t accidentally pull in tests, mocks, or build artifacts.

```json
"include": ["src"],
"exclude": ["dist", "node_modules", "**/*.test.ts"]
```

---

## ⚙️ 2) Config flags that help performance

### `"incremental": true`

Creates a `.tsbuildinfo` cache so re-runs only check changed files.
Essential for large apps.

### `"skipLibCheck": true`

Skips type-checking every dependency’s `.d.ts`.
Huge speedup, almost no downside for apps (but not libraries).

### `"isolatedModules": true`

Forces each file to be type-checked independently.
Needed for Babel/ts-jest, but also prevents “cross-file” inference, which can slightly *speed up* incremental builds.

### `"noEmit": true"`

If you’re using a separate bundler, skip emitting JS.
Type-checking only = less work.

### `"composite": true"`

Required for project references; stores metadata for incremental builds.

### `"skipDefaultLibCheck": true"`

Even faster, rarely needed; disables checking built-in lib files like `es2022.d.ts`.

---

## 🧠 3) Type-design hygiene (the hidden cost)

### a) Avoid runaway conditional or recursive types

Complex utility types can explode combinatorially.

```ts
type DeepPartial<T> = {
  [K in keyof T]?: DeepPartial<T[K]>;
};
```

Great for data shapes — but stack it 10 levels deep on union types and you can feel the lag.
Use them sparingly or constrain input (`extends object`).

### b) Prefer explicit types over huge inferred unions

When TS infers a massive literal union from constants, you can help it:

```ts
const ROUTES = { a: "/a", b: "/b", c: "/c" } as const;
type Route = keyof typeof ROUTES; // ✅ simple
```

vs.

```ts
type Route = keyof typeof bigDynamicObject; // 🐢
```

### c) Use `unknown` strategically

`unknown` tells TS to stop expanding infinite unions — helpful in deeply nested generic utilities.

### d) Cap generic recursion depth

If you author utilities, guard recursion:

```ts
type Flatten<T, D extends number = 10> =
  D extends 0 ? T : T extends any[] ? Flatten<T[number], D extends infer R ? R : never> : T;
```

Yes, gnarly — but it stops TS from infinite evaluation.

---

## 🔧 4) DX & tooling tricks

* **VS Code:** set `"typescript.tsserver.maxTsServerMemory": 4096` if IntelliSense lags on huge projects.
* **`tsc --diagnostics`** shows timing and memory per phase.
* **`tsc --generateTrace trace.json`** creates a Chrome-inspectable profile.
* **`typescript-language-server`** in editors can share caches across projects.

---

## 🚀 5) Typical performance-oriented tsconfig baseline

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "strict": true,
    "skipLibCheck": true,
    "incremental": true,
    "composite": true,
    "noEmit": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "bundler",
    "isolatedModules": true
  },
  "include": ["src"]
}
```

---

## 💬 Interview-ready answer

> TypeScript performance problems come from re-checking too much or evaluating overly complex types.
>
> I split projects with `composite` + `references`, enable incremental builds and `skipLibCheck`, and keep my `include` set tight.
>
> On the type-system side, I avoid deep recursive generics and massive unions, and I pre-compute helper types instead of nesting them.
>
> For day-to-day speed I run `tsc --noEmit --incremental` and watch diagnostics — TypeScript is deterministic, so structure and hygiene go a long way toward keeping it fast.

---

Next up would be **Q21 – “Source of truth: types vs runtime validation”**, which covers how to balance TypeScript types with libraries like Zod or Valibot. Continue?
