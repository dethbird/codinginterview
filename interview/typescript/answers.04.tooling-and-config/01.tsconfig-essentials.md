# 18. **`tsconfig` essentials:** What do `strict`, `noUncheckedIndexedAccess`, `exactOptionalPropertyTypes`, and `skipLibCheck` change?

## a

## A

Excellent — `tsconfig.json` is where you tell the compiler *how strict, smart, and fast* to be. A good interviewer question about it isn’t about memorizing flags; it’s about showing you understand **what guarantees each flag gives you** and **why you’d toggle them**.

Let’s go through the essentials.

---

## 🧩 1) `strict` — the master switch

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

Enables the full “strict mode family”:

* `noImplicitAny`
* `noImplicitThis`
* `strictNullChecks`
* `strictBindCallApply`
* `strictFunctionTypes`
* `strictPropertyInitialization`
* `alwaysStrict`

### Why it matters

This is how you get real type safety — every other flag below is either included in or supplements `strict`.

---

## 🧠 2) `noUncheckedIndexedAccess`

Forces you to handle possibly-`undefined` values from index access.

```ts
const arr = [1, 2, 3];
const x = arr[5]; // x: number | undefined
```

**Why it’s good:** avoids “cannot read property of undefined” at runtime.
**Trade-off:** adds more unions; can make code noisier.

---

## ⚙️ 3) `exactOptionalPropertyTypes`

Distinguishes between *omitted* and *explicitly undefined* props.

Without it:

```ts
type T = { x?: number };
const t: T = { x: undefined }; // ✅ allowed
```

With it:

```ts
// now x?: number is NOT the same as x?: number | undefined
const t: T = { x: undefined }; // ❌ must omit or widen
```

**Why it’s good:** clarifies optional vs `undefined` semantics.
**When to use:** when modeling API payloads or JSON schemas precisely.

---

## 🔍 4) `skipLibCheck`

Skips type checking of `.d.ts` files in `node_modules`.
**Why:** faster compilation, fewer spurious third-party errors.
**Downside:** you might miss subtle version mismatches.
**Best practice:** leave it on in big projects, off when authoring a library.

---

## 🔄 5) `esModuleInterop` and `allowSyntheticDefaultImports`

Interop between CommonJS (`require()`) and ES modules (`import ... from`).

Without it:

```ts
import fs from "fs"; // ❌ error
```

With it:

```ts
import fs from "fs"; // ✅
```

**Why it’s good:** makes import syntax consistent; mandatory in most modern setups.
**Caution:** only affects types — actual runtime behavior depends on your bundler or Node flags.

---

## 🌐 6) `moduleResolution` & module system flags

* `"moduleResolution": "node"` or `"bundler"` — how TS finds your imports.
* `"module": "esnext" | "commonjs"` — what JS format to emit.
* `"resolveJsonModule": true` — import `.json` as typed modules.

**Why they matter:** ensure type lookup matches your build tool (Vite, Webpack, Node ESM, etc.).

---

## 🚀 7) `target` & `lib`

These control *emitted JS* and *type availability*.

```json
"target": "ES2022",
"lib": ["DOM", "ES2022"]
```

**Tip:** use a modern `target` (ES2020+) to get async iterators, nullish coalescing, etc.

---

## 🧩 8) Performance & DX

* `"incremental": true` + `"tsBuildInfoFile"` → cached builds.
* `"isolatedModules": true"` → required for Babel/ts-jest.
* `"noEmitOnError": true"` → prevent broken JS output.
* `"forceConsistentCasingInFileNames": true"` → cross-OS sanity.

---

## 🔐 9) Custom strictness combos (real-world setups)

**Frontend apps**

```json
{
  "strict": true,
  "noUncheckedIndexedAccess": true,
  "exactOptionalPropertyTypes": true,
  "skipLibCheck": true,
  "esModuleInterop": true
}
```

**Libraries**

```json
{
  "strict": true,
  "noUncheckedIndexedAccess": true,
  "exactOptionalPropertyTypes": true,
  "skipLibCheck": false,
  "declaration": true,
  "isolatedModules": false
}
```

---

## 💬 Interview-ready answer

> The `tsconfig.json` controls how TypeScript interprets, checks, and emits your code.
> I always enable `strict`, which bundles the core safety checks, and often add `noUncheckedIndexedAccess` for array safety and `exactOptionalPropertyTypes` for accurate API modeling.
> For ergonomics, I keep `skipLibCheck` on in apps but off in libraries.
>
> `esModuleInterop` and `moduleResolution` ensure imports behave the same way as at runtime.
> Altogether, the right config balances *safety* (more unions, stricter checks) and *DX* (faster builds, cleaner errors) depending on project scale.

---

Next up: **Q19 – ESM vs CJS interop & moduleResolution gotchas** — want to dive into that next?
