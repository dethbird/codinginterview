# 18. **`tsconfig` essentials:** What do `strict`, `noUncheckedIndexedAccess`, `exactOptionalPropertyTypes`, and `skipLibCheck` change?

## a

## A

Excellent â€” `tsconfig.json` is where you tell the compiler *how strict, smart, and fast* to be. A good interviewer question about it isnâ€™t about memorizing flags; itâ€™s about showing you understand **what guarantees each flag gives you** and **why youâ€™d toggle them**.

Letâ€™s go through the essentials.

---

## ðŸ§© 1) `strict` â€” the master switch

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

Enables the full â€œstrict mode familyâ€:

* `noImplicitAny`
* `noImplicitThis`
* `strictNullChecks`
* `strictBindCallApply`
* `strictFunctionTypes`
* `strictPropertyInitialization`
* `alwaysStrict`

### Why it matters

This is how you get real type safety â€” every other flag below is either included in or supplements `strict`.

---

## ðŸ§  2) `noUncheckedIndexedAccess`

Forces you to handle possibly-`undefined` values from index access.

```ts
const arr = [1, 2, 3];
const x = arr[5]; // x: number | undefined
```

**Why itâ€™s good:** avoids â€œcannot read property of undefinedâ€ at runtime.
**Trade-off:** adds more unions; can make code noisier.

---

## âš™ï¸ 3) `exactOptionalPropertyTypes`

Distinguishes between *omitted* and *explicitly undefined* props.

Without it:

```ts
type T = { x?: number };
const t: T = { x: undefined }; // âœ… allowed
```

With it:

```ts
// now x?: number is NOT the same as x?: number | undefined
const t: T = { x: undefined }; // âŒ must omit or widen
```

**Why itâ€™s good:** clarifies optional vs `undefined` semantics.
**When to use:** when modeling API payloads or JSON schemas precisely.

---

## ðŸ” 4) `skipLibCheck`

Skips type checking of `.d.ts` files in `node_modules`.
**Why:** faster compilation, fewer spurious third-party errors.
**Downside:** you might miss subtle version mismatches.
**Best practice:** leave it on in big projects, off when authoring a library.

---

## ðŸ”„ 5) `esModuleInterop` and `allowSyntheticDefaultImports`

Interop between CommonJS (`require()`) and ES modules (`import ... from`).

Without it:

```ts
import fs from "fs"; // âŒ error
```

With it:

```ts
import fs from "fs"; // âœ…
```

**Why itâ€™s good:** makes import syntax consistent; mandatory in most modern setups.
**Caution:** only affects types â€” actual runtime behavior depends on your bundler or Node flags.

---

## ðŸŒ 6) `moduleResolution` & module system flags

* `"moduleResolution": "node"` or `"bundler"` â€” how TS finds your imports.
* `"module": "esnext" | "commonjs"` â€” what JS format to emit.
* `"resolveJsonModule": true` â€” import `.json` as typed modules.

**Why they matter:** ensure type lookup matches your build tool (Vite, Webpack, Node ESM, etc.).

---

## ðŸš€ 7) `target` & `lib`

These control *emitted JS* and *type availability*.

```json
"target": "ES2022",
"lib": ["DOM", "ES2022"]
```

**Tip:** use a modern `target` (ES2020+) to get async iterators, nullish coalescing, etc.

---

## ðŸ§© 8) Performance & DX

* `"incremental": true` + `"tsBuildInfoFile"` â†’ cached builds.
* `"isolatedModules": true"` â†’ required for Babel/ts-jest.
* `"noEmitOnError": true"` â†’ prevent broken JS output.
* `"forceConsistentCasingInFileNames": true"` â†’ cross-OS sanity.

---

## ðŸ” 9) Custom strictness combos (real-world setups)

**Frontend apps**

```json
{
  "strict": true,
  "noUncheckedIndexedAccess": true,
  "exactOptionalPropertyTypes": true,
  "skipLibCheck": true,
  "esModuleInterop": true
}
```

**Libraries**

```json
{
  "strict": true,
  "noUncheckedIndexedAccess": true,
  "exactOptionalPropertyTypes": true,
  "skipLibCheck": false,
  "declaration": true,
  "isolatedModules": false
}
```

---

## ðŸ’¬ Interview-ready answer

> The `tsconfig.json` controls how TypeScript interprets, checks, and emits your code.
> I always enable `strict`, which bundles the core safety checks, and often add `noUncheckedIndexedAccess` for array safety and `exactOptionalPropertyTypes` for accurate API modeling.
> For ergonomics, I keep `skipLibCheck` on in apps but off in libraries.
>
> `esModuleInterop` and `moduleResolution` ensure imports behave the same way as at runtime.
> Altogether, the right config balances *safety* (more unions, stricter checks) and *DX* (faster builds, cleaner errors) depending on project scale.

---

Next up: **Q19 â€“ ESM vs CJS interop & moduleResolution gotchas** â€” want to dive into that next?
