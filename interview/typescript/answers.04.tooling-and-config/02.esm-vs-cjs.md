# 19. **`esModuleInterop`, `moduleResolution`, ESM vs CJS:** Common interop gotchas and fixes.

## a

## A

Perfect â€” this oneâ€™s both deeply practical and an instant credibility builder in an interview, because ESM/CommonJS headaches are the bane of every mid-senior TypeScript engineer. Letâ€™s go through what these settings actually mean, how they interact, and what can go wrong.

---

## ðŸ§© 1) ESM vs. CJS â€” the two worlds

**CommonJS (CJS)**

* Default in older Node.js and many npm packages.
* Uses `require()` and `module.exports`.
* Synchronous module loading.
* Files typically end in `.js`.

```js
// CommonJS
const fs = require("fs");
module.exports = { read };
```

**ES Modules (ESM)**

* Official modern standard.
* Uses `import` / `export`.
* Static structure â†’ better tree-shaking.
* Uses `.mjs` or `"type": "module"` in package.json.

```js
// ES module
import fs from "fs";
export function read() {}
```

**At runtime:** Node must know which system youâ€™re using.
**At compile time:** TypeScript must output code that *matches* your runtime.

---

## ðŸ§  2) TypeScriptâ€™s side: `module`, `target`, and `moduleResolution`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "node"
  }
}
```

* `"module"` decides what TS **emits**: ES `import/export` or CJS `require()`.
* `"target"` affects *syntax down-leveling* (e.g., async/await â†’ generators).
* `"moduleResolution"` tells TS how to **find** your imports â€” usually `"node"` or `"bundler"`.

### Common combos

| Use case                          | `"module"`   | `"moduleResolution"`      | Notes                                       |
| --------------------------------- | ------------ | ------------------------- | ------------------------------------------- |
| Modern ESM Node project           | `"ESNext"`   | `"node16"` or `"bundler"` | Use `"type": "module"` in `package.json`.   |
| Legacy Node (CJS)                 | `"CommonJS"` | `"node"`                  | The old default.                            |
| Frontend bundlers (Vite, Webpack) | `"ESNext"`   | `"bundler"`               | Lets TS skip runtime-only resolution logic. |

---

## âš™ï¸ 3) The bridge: `esModuleInterop` and `allowSyntheticDefaultImports`

TypeScriptâ€™s type system must pretend that CommonJS modules sometimes *act* like ESM modules â€” otherwise half of npm would break.

```json
{
  "compilerOptions": {
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
```

* **`esModuleInterop`** rewrites `import fs from "fs"` into `import * as fs` if necessary.
* **`allowSyntheticDefaultImports`** lets you *type-check* that import even if no default export exists.
* Theyâ€™re purely compile-time; they donâ€™t change your runtime module loader.

Without it:

```ts
import fs from "fs"; // âŒ 'fs' has no default export
const fs = require("fs"); // âœ… old syntax
```

With it:

```ts
import fs from "fs"; // âœ…
```

Most modern projects keep both **on**.

---

## ðŸ§© 4) Typical interop gotchas

### a) Mixing import and require in the same file

Node interprets ESM and CJS differently:

```ts
import fs from "fs";
const os = require("os"); // âŒ in pure ESM
```

â†’ either convert to ESM (`import`) or rename the file to `.cjs` if you need `require()`.

---

### b) Wrong `"type"` in package.json

If you set `"type": "module"` but compile to `"CommonJS"`, Node will crash:

```bash
Error [ERR_REQUIRE_ESM]: Must use import to load ES Module
```

**Rule:** emitted code format (`"module"`) must match your package.json type.

---

### c) Dual packages & `require()` users

If youâ€™re publishing a library:

* Use separate build outputs: `dist/esm` + `dist/cjs`.
* Point to both in `package.json`:

  ```json
  {
    "main": "dist/cjs/index.cjs",
    "module": "dist/esm/index.js",
    "types": "dist/index.d.ts"
  }
  ```

---

### d) `moduleResolution` mismatch

* `"node"`: uses Nodeâ€™s resolution (checks `.ts`, `.tsx`, `.js`, `index.ts`, etc.).
* `"node16"`: newer algorithm aware of `"exports"` and `"imports"` in package.json.
* `"bundler"`: assumes your bundler (Vite, Webpack) resolves files and skips path extension checks.

If you see `Cannot find module` errors that work in runtime, your resolution mode likely mismatches your environment.

---

## âœ… 5) Safe configuration patterns

**Frontend app (Vite, Next.js, etc.):**

```json
{
  "target": "ES2022",
  "module": "ESNext",
  "moduleResolution": "bundler",
  "esModuleInterop": true,
  "allowSyntheticDefaultImports": true
}
```

**Node ESM app:**

```json
{
  "target": "ES2022",
  "module": "ESNext",
  "moduleResolution": "node16",
  "esModuleInterop": true,
  "allowSyntheticDefaultImports": true
}
```

and `"type": "module"` in `package.json`.

**Node CommonJS app:**

```json
{
  "target": "ES2022",
  "module": "CommonJS",
  "moduleResolution": "node",
  "esModuleInterop": true
}
```

---

## ðŸ’¬ Interview-ready answer

> ESM and CommonJS are two different module systems â€” `import/export` vs `require/module.exports`.
> TypeScript has to know both how to **find** modules (`moduleResolution`) and how to **emit** them (`module`).
> `esModuleInterop` and `allowSyntheticDefaultImports` exist to make CommonJS packages work with `import` syntax.
>
> In practice, for modern ESM or frontend projects I set `"module": "ESNext"` and `"moduleResolution": "bundler"` or `"node16"`, with `esModuleInterop` on.
> For legacy Node, `"module": "CommonJS"`.
> Matching the emitted format to the runtime environment avoids `ERR_REQUIRE_ESM` and missing default export errors.

---

Next up: **Q20 â€“ Performance & compile-time optimization** (how to tame slow type checking in large projects). Would you like to dive into that?
