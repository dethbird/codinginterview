# 6. **Enum vs union of literals:** Tradeoffs, tree-shaking, and interop considerations.

## a

I think this is about the explicit Enum type but again, I think I need help on this whole question.

## A

You’re right that this is about the explicit `enum` construct vs using a union of literal values. Let’s lock it in.

---

### What you got right

* You recognized we’re comparing the `enum` keyword to unions of literals. That’s the core axis.

---

### What you missed

* **Runtime vs. type-only:** Enums emit JavaScript at runtime; unions of literals are erased. This drives most tradeoffs (bundle size, tree-shaking, interop).
* **Kinds of enums:** numeric, string, and `const enum` behave differently (reverse mapping, emission, Babel/ts-jest compatibility).
* **Tree-shaking and interop details:** unions are great for DCE and JSON interop; enums help when you need a runtime namespace or numeric codes.

---

### Technical details (with examples)

#### 1) Runtime emission & tree-shaking

* **`enum`** (regular): compiles to a JS object. That’s **runtime code**.

  ```ts
  // TS
  enum Status { Ok = 200, NotFound = 404 }

  // JS (roughly)
  var Status = { 200: "Ok", 404: "NotFound", Ok: 200, NotFound: 404 }; // reverse map for numeric enums
  ```

  * **Pros:** single namespace you can import; reverse mapping for numeric enums (`Status[200] === "Ok"`).
  * **Cons:** extra runtime bytes; harder to tree-shake if partially used.

* **Union of literals**: **type-only**; nothing is emitted.

  ```ts
  type Status = 200 | 404;               // numeric union
  type Role = "admin" | "user" | "ops";  // string union
  ```

  * **Pros:** zero runtime cost; best for tree-shaking and bundle size.
  * **Cons:** you don’t get a runtime container of values unless you build one.

* **`const enum`**: inlines values at use sites (no object emitted).

  ```ts
  const enum Color { Red = "red", Blue = "blue" }
  const c = Color.Red; // becomes "red" in JS
  ```

  * **Pros:** minimal JS like unions.
  * **Cons:** tooling caveats—Babel/ts-jest don’t transform `const enum` unless special plugins are used; `preserveConstEnums` changes semantics; exporting `const enum` from libraries can break consumers. Many teams ban `const enum` for this reason.

#### 2) String vs numeric behavior

* **Numeric enums** get reverse mapping in JS; **string enums** do not:

  ```ts
  enum Num { A = 1 }            // Num[1] === "A" ✅
  enum Str { A = "A" }          // Str["A"] === undefined ❌
  ```
* **Unions** are just values—no reverse map, but often simpler for JSON APIs.

#### 3) Ergonomics in code

* **Discriminated unions** pair naturally with literal unions:

  ```ts
  type Shape =
    | { kind: "circle"; r: number }
    | { kind: "square"; s: number };
  // switch(shape.kind) ... exhaustive checks work beautifully
  ```

* **Enums** provide a **runtime namespace** (nice with switches/logging):

  ```ts
  enum Kind { Circle = "circle", Square = "square" }
  type Shape =
    | { kind: Kind.Circle; r: number }
    | { kind: Kind.Square; s: number };
  ```

* If you want a **runtime object** plus a **type union**, create a frozen object and infer:

  ```ts
  const Kind = { Circle: "circle", Square: "square" } as const;
  type Kind = typeof Kind[keyof typeof Kind]; // "circle" | "square"
  ```

#### 4) Interop considerations

* **APIs/JSON:** unions of string literals match common REST/JSON data; no mapping required.
* **Legacy or cross-language SDKs:** **numeric enums** are handy when the backend speaks integer codes (gRPC/Protobuf, older .NET/Java services).
* **Third-party types:** enums are “closed” and can’t be extended; unions can be extended via **union augmentation** patterns if you own the type.

#### 5) Exhaustiveness & safety

* Both work with exhaustive `switch`.
* With unions, you can add `as const` objects and still retain literal types.
* With enums, you sometimes see fall-through bugs if you accidentally use the wrong enum in a function—less likely with unions tied to domain strings.

#### 6) Tooling & config foot-guns

* `const enum` + Babel/ts-jest + `isolatedModules` frequently breaks unless you add the proper transform. Many codebases avoid `const enum` for portability.
* `keyof typeof Enum` is your friend to derive unions from an enum’s keys or values when you need both worlds.

---

### Pitfalls (one each)

* **Union pitfall:** accessing properties specific to one variant **without narrowing**.

  ```ts
  type T = { a: string } | { b: number };
  // t.a  // ❌ must check "in" first
  ```

* **Intersection pitfall (for contrast):** intersecting incompatible members collapses to `never` (mentioned earlier). For enums specifically:

* **Enum pitfall:** shipping **`const enum`** across package boundaries or compiling with a toolchain that doesn’t transform them → runtime `ReferenceError` or wrong values.

---

### How to choose (practical rubric)

* **Frontend apps, JSON APIs, React props, discriminated unions:**
  Prefer **unions of string literals** (+ `as const` objects if you need a runtime list).

* **Interop with backends that use numeric codes, or you want a runtime namespace:**
  Use **enums** (often **string enums**). Avoid `const enum` unless your toolchain is aligned and the enum won’t cross package boundaries.

* **Bundle size and tree-shaking top priority:**
  Prefer **unions**. (Enums generate runtime code; unions don’t.)

---

### Interview-ready answer

> Enums and unions both model finite sets of values, but they live differently at runtime.
>
> * A regular **`enum`** emits a JavaScript object, giving you a runtime namespace (and reverse mapping for numeric enums). That’s great for interop with systems that use numeric codes or when you want a concrete value bag, but it adds bytes and can hinder tree-shaking.
> * A **union of literals** is type-only and erases at compile time, so it’s ideal for frontend apps, JSON APIs, and discriminated unions—small bundles and easy exhaustive checks.
> * **`const enum`** inlines values (tiny bundles) but is fragile across toolchains and package boundaries; many teams avoid it.
>
> My default: use **literal unions** (often backed by an `as const` object if I need the runtime values). I reach for **enums** when interop or a runtime namespace is more valuable than the extra JS.

---

Ready for **Q7: Generic functions and constraints** next, or do you want to jump to a practical (e.g., **P5 `RequiredBy<T, K>`**) for a change of pace?
