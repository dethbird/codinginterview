# 5. **Union vs intersection types:** Practical differences and a pitfall for each.

## a

A union is a merge of all bits of a type. Intersection is only the ones that overlap. I actually don't know the answer to differences and pitfalls. Please

## A

Perfect — that’s exactly why we’re doing this. You’re thinking in the right direction, but the intuition about “overlap” needs tightening. The key mental model is that **unions represent *either/or*, while intersections represent *both/and*.**

Let’s build that up properly.

---

### ✅ What you’ve got right

You recognized that both **union (`|`)** and **intersection (`&`)** combine types in some way — that’s the right conceptual family. Now we’ll sort out *how* they combine.

---

### 🧠 The real difference

| Concept          | Operator | Meaning                                                   | Example                                     | Type-level idea                    |         |                         |
| ---------------- | -------- | --------------------------------------------------------- | ------------------------------------------- | ---------------------------------- | ------- | ----------------------- |
| **Union**        | `        | `                                                         | “A **or** B” — a value can be *either* type | `string                            | number` | *Sum type* (either one) |
| **Intersection** | `&`      | “A **and** B” — a value must satisfy *both* types at once | `{id: string} & {name: string}`             | *Product type* (merged properties) |         |                         |

---

### 🪄 Union type: “one of many”

A **union** means the value could be any of several possible shapes.
You must *narrow* before you can use properties safely.

```ts
type Input = string | number;

function printLength(x: Input) {
  // x could be string or number
  if (typeof x === "string") {
    console.log(x.length); // ✅
  } else {
    console.log(x.toFixed(2)); // ✅
  }
}
```

**Pitfall:**
If you try to access something not common to all members, TypeScript complains.

```ts
x.length; // ❌ Error — not all members have 'length'
```

That’s good: it forces you to narrow first.

---

### ⚙️ Intersection type: “combine multiple types”

An **intersection** means the value *must* have everything from all included types.

```ts
type HasId = { id: string };
type HasName = { name: string };

type User = HasId & HasName;

const u: User = { id: "123", name: "Cher" }; // ✅
```

This is how you build complex composite types.

**Pitfall:**
Intersections between incompatible types become **never** — impossible.

```ts
type A = { kind: "a" };
type B = { kind: "b" };

type Impossible = A & B; 
// type Impossible = never (because 'kind' cannot be both 'a' and 'b')
```

Or with primitives:

```ts
type Weird = string & number; // never
```

That’s the “bite”: intersections can collapse to nothing if types can’t coexist.

---

### 🧩 Practical uses

* **Union:** modeling variants or flexible APIs (e.g., `string | number | null`)
* **Intersection:** composing multiple traits or requirements (e.g., `User & AdminPermissions`)

They often work together:

```ts
type Response<T> = { data: T } | { error: string }; // Union
type User = Person & Timestamped; // Intersection
```

---

### 💬 Interview-ready answer

> Unions and intersections combine types in opposite ways.
>
> A **union (`A | B`)** means the value can be *either* type — you’ll often narrow it with checks before using it. The main pitfall is that you can’t safely access properties unless they exist on *all* union members.
>
> An **intersection (`A & B`)** means the value must satisfy *both* types — it merges their requirements. The pitfall there is that if the types are incompatible, the intersection collapses to `never`.
>
> In practice, unions model *variants* and intersections model *composed traits.*

---

Want to keep rolling with **Q6 – Enum vs union of literals**? It’s a neat one because it blends runtime and compile-time concerns.
