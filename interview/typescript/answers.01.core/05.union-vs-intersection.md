# 5. **Union vs intersection types:** Practical differences and a pitfall for each.

## a

A union is a merge of all bits of a type. Intersection is only the ones that overlap. I actually don't know the answer to differences and pitfalls. Please

## A

Perfect â€” thatâ€™s exactly why weâ€™re doing this. Youâ€™re thinking in the right direction, but the intuition about â€œoverlapâ€ needs tightening. The key mental model is that **unions represent *either/or*, while intersections represent *both/and*.**

Letâ€™s build that up properly.

---

### âœ… What youâ€™ve got right

You recognized that both **union (`|`)** and **intersection (`&`)** combine types in some way â€” thatâ€™s the right conceptual family. Now weâ€™ll sort out *how* they combine.

---

### ğŸ§  The real difference

| Concept          | Operator | Meaning                                                   | Example                                     | Type-level idea                    |         |                         |
| ---------------- | -------- | --------------------------------------------------------- | ------------------------------------------- | ---------------------------------- | ------- | ----------------------- |
| **Union**        | `        | `                                                         | â€œA **or** Bâ€ â€” a value can be *either* type | `string                            | number` | *Sum type* (either one) |
| **Intersection** | `&`      | â€œA **and** Bâ€ â€” a value must satisfy *both* types at once | `{id: string} & {name: string}`             | *Product type* (merged properties) |         |                         |

---

### ğŸª„ Union type: â€œone of manyâ€

A **union** means the value could be any of several possible shapes.
You must *narrow* before you can use properties safely.

```ts
type Input = string | number;

function printLength(x: Input) {
  // x could be string or number
  if (typeof x === "string") {
    console.log(x.length); // âœ…
  } else {
    console.log(x.toFixed(2)); // âœ…
  }
}
```

**Pitfall:**
If you try to access something not common to all members, TypeScript complains.

```ts
x.length; // âŒ Error â€” not all members have 'length'
```

Thatâ€™s good: it forces you to narrow first.

---

### âš™ï¸ Intersection type: â€œcombine multiple typesâ€

An **intersection** means the value *must* have everything from all included types.

```ts
type HasId = { id: string };
type HasName = { name: string };

type User = HasId & HasName;

const u: User = { id: "123", name: "Cher" }; // âœ…
```

This is how you build complex composite types.

**Pitfall:**
Intersections between incompatible types become **never** â€” impossible.

```ts
type A = { kind: "a" };
type B = { kind: "b" };

type Impossible = A & B; 
// type Impossible = never (because 'kind' cannot be both 'a' and 'b')
```

Or with primitives:

```ts
type Weird = string & number; // never
```

Thatâ€™s the â€œbiteâ€: intersections can collapse to nothing if types canâ€™t coexist.

---

### ğŸ§© Practical uses

* **Union:** modeling variants or flexible APIs (e.g., `string | number | null`)
* **Intersection:** composing multiple traits or requirements (e.g., `User & AdminPermissions`)

They often work together:

```ts
type Response<T> = { data: T } | { error: string }; // Union
type User = Person & Timestamped; // Intersection
```

---

### ğŸ’¬ Interview-ready answer

> Unions and intersections combine types in opposite ways.
>
> A **union (`A | B`)** means the value can be *either* type â€” youâ€™ll often narrow it with checks before using it. The main pitfall is that you canâ€™t safely access properties unless they exist on *all* union members.
>
> An **intersection (`A & B`)** means the value must satisfy *both* types â€” it merges their requirements. The pitfall there is that if the types are incompatible, the intersection collapses to `never`.
>
> In practice, unions model *variants* and intersections model *composed traits.*

---

Want to keep rolling with **Q6 â€“ Enum vs union of literals**? Itâ€™s a neat one because it blends runtime and compile-time concerns.
