# 1. **Any vs unknown vs never:** When do you use each, and why does `unknown` exist if `any` already does?

## a

I know any is the most permissive you can have. It's almost like having no type set at all. But I may need help. I don't know why / where you would use unknown or never.

## A

Excellent place to begin â€” this is one of those deceptively simple TypeScript questions thatâ€™s really about how the type system enforces **trust** vs **safety**.

---

### ğŸ§© What you got right

You correctly identified that `any` is the *most permissive* type â€” essentially an â€œescape hatchâ€ from the type system. It disables type checking for whatever it touches. Thatâ€™s a key intuition and exactly how most developers misuse it.

---

### âš ï¸ What you missed or need to clarify

* `unknown` is *also* a top type (like `any`), but it **forces you to prove whatâ€™s inside** before using it. Think of it as â€œI truly donâ€™t know what this is yet.â€
* `never` is the *bottom type* â€” a value that can never exist. It shows up in impossible branches, functions that always throw, or exhaustive `switch` checks.
* The reason `unknown` exists is to allow you to model uncertainty *safely* â€” for example, parsing `JSON.parse()` or working with dynamic input. You can assign anything **to** `unknown`, but you canâ€™t assign `unknown` **to** anything else without checking or asserting.

---

### ğŸ§  Technical details

| Type      | Description                                                       | Can assign **to** | Can assign **from**    | Typical use                                |
| --------- | ----------------------------------------------------------------- | ----------------- | ---------------------- | ------------------------------------------ |
| `any`     | Opt-out of type checking. You can do anything to it.              | Everything        | Everything             | Migrating JS, suppressing type errors      |
| `unknown` | Type-safe counterpart to `any`. Must narrow before using.         | Everything        | Only `unknown` & `any` | Unvalidated input, safe â€œI donâ€™t know yetâ€ |
| `never`   | No possible value. Function that never returns, unreachable code. | Nothing           | Everything             | Exhaustive checks, fail-fast functions     |

Examples:

```ts
let a: any = 42;
a.foo.bar(); // OK at compile time, might explode at runtime

let u: unknown = 42;
u + 1; // âŒ Error â€“ must narrow first
if (typeof u === "number") {
  console.log(u + 1); // âœ… Safe
}

function fail(msg: string): never {
  throw new Error(msg);
}

// Exhaustiveness check:
type Shape = { kind: "circle"; r: number } | { kind: "square"; s: number };
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.r ** 2;
    case "square": return shape.s ** 2;
    default: 
      const _exhaustive: never = shape; // ğŸš¨ Compile error if new kind added
      return _exhaustive;
  }
}
```

---

### ğŸ’¬ Interview-ready answer

> `any`, `unknown`, and `never` represent the extremes of TypeScriptâ€™s type system.
>
> * `any` disables type safety â€” you can assign or call anything on it, which is useful when migrating from JavaScript but risky for long-term code.
> * `unknown` is the type-safe version of `any`: you can store anything in it, but you canâ€™t use it without checking or narrowing first. Itâ€™s great for unvalidated input like parsed JSON or external data.
> * `never` represents something that canâ€™t happen â€” a function that never returns or an unreachable code path. Itâ€™s often used for exhaustive `switch` statements to ensure all variants are handled.
>
> `unknown` exists because it lets you handle dynamic data safely, while still leveraging TypeScriptâ€™s checking â€” itâ€™s â€œI donâ€™t know yet,â€ not â€œI donâ€™t care.â€

---

Want to move on to **Q2 (Type aliases vs interfaces)** next?
