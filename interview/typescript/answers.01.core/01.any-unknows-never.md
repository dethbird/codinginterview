# 1. **Any vs unknown vs never:** When do you use each, and why does `unknown` exist if `any` already does?

## a

I know any is the most permissive you can have. It's almost like having no type set at all. But I may need help. I don't know why / where you would use unknown or never.

## A

Excellent place to begin — this is one of those deceptively simple TypeScript questions that’s really about how the type system enforces **trust** vs **safety**.

---

### 🧩 What you got right

You correctly identified that `any` is the *most permissive* type — essentially an “escape hatch” from the type system. It disables type checking for whatever it touches. That’s a key intuition and exactly how most developers misuse it.

---

### ⚠️ What you missed or need to clarify

* `unknown` is *also* a top type (like `any`), but it **forces you to prove what’s inside** before using it. Think of it as “I truly don’t know what this is yet.”
* `never` is the *bottom type* — a value that can never exist. It shows up in impossible branches, functions that always throw, or exhaustive `switch` checks.
* The reason `unknown` exists is to allow you to model uncertainty *safely* — for example, parsing `JSON.parse()` or working with dynamic input. You can assign anything **to** `unknown`, but you can’t assign `unknown` **to** anything else without checking or asserting.

---

### 🧠 Technical details

| Type      | Description                                                       | Can assign **to** | Can assign **from**    | Typical use                                |
| --------- | ----------------------------------------------------------------- | ----------------- | ---------------------- | ------------------------------------------ |
| `any`     | Opt-out of type checking. You can do anything to it.              | Everything        | Everything             | Migrating JS, suppressing type errors      |
| `unknown` | Type-safe counterpart to `any`. Must narrow before using.         | Everything        | Only `unknown` & `any` | Unvalidated input, safe “I don’t know yet” |
| `never`   | No possible value. Function that never returns, unreachable code. | Nothing           | Everything             | Exhaustive checks, fail-fast functions     |

Examples:

```ts
let a: any = 42;
a.foo.bar(); // OK at compile time, might explode at runtime

let u: unknown = 42;
u + 1; // ❌ Error – must narrow first
if (typeof u === "number") {
  console.log(u + 1); // ✅ Safe
}

function fail(msg: string): never {
  throw new Error(msg);
}

// Exhaustiveness check:
type Shape = { kind: "circle"; r: number } | { kind: "square"; s: number };
function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.r ** 2;
    case "square": return shape.s ** 2;
    default: 
      const _exhaustive: never = shape; // 🚨 Compile error if new kind added
      return _exhaustive;
  }
}
```

---

### 💬 Interview-ready answer

> `any`, `unknown`, and `never` represent the extremes of TypeScript’s type system.
>
> * `any` disables type safety — you can assign or call anything on it, which is useful when migrating from JavaScript but risky for long-term code.
> * `unknown` is the type-safe version of `any`: you can store anything in it, but you can’t use it without checking or narrowing first. It’s great for unvalidated input like parsed JSON or external data.
> * `never` represents something that can’t happen — a function that never returns or an unreachable code path. It’s often used for exhaustive `switch` statements to ensure all variants are handled.
>
> `unknown` exists because it lets you handle dynamic data safely, while still leveraging TypeScript’s checking — it’s “I don’t know yet,” not “I don’t care.”

---

Want to move on to **Q2 (Type aliases vs interfaces)** next?
