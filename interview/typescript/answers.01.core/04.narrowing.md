# 4. **Narrowing:** Walk through control-flow based narrowing (type guards, `in`, `typeof`, `instanceof`, discriminants).

## a

At the function definition level you can type the arguments. If this must be unknown, then type checking must happen in the function. You can use union with `in` - where the `typeof` the argument must be in [keys]. You use `instanceof` to specifically as if an argument is of a particular type. I don't know what discriminants are. 

## A

Nice, you’ve got the essence — narrowing is all about **turning uncertainty into certainty** through checks in your code. You correctly identified the key tools (`typeof`, `in`, `instanceof`) and the idea that this is especially relevant when working with `unknown` or union types. Let’s fill in the full picture and clarify “discriminants,” which are one of TypeScript’s most elegant features.

---

### ✅ What you got right

* You understood narrowing happens *within a function or block* as TypeScript refines the possible type of a variable.
* You recognized that `typeof`, `in`, and `instanceof` are how you perform these runtime checks.
* You also correctly noted that narrowing matters when something begins as `unknown` or a **union** type.

---

### ⚠️ What needs refining

* The purpose isn’t just checking — it’s that **TypeScript automatically narrows the variable’s type** based on the control flow (if-else branches, guards, etc.).
* “Discriminants” refer to **a common property shared by union members** that acts as a tag or label for which variant you’re dealing with.
* You can also define **custom type guards**—functions that return `value is Type` instead of `boolean`.

---

### 🧠 Technical breakdown

#### Control-flow based narrowing

TypeScript watches how your code flows and *narrows* variable types as you check them.

```ts
function printValue(value: string | number) {
  if (typeof value === "string") {
    // Here value: string
    console.log(value.toUpperCase());
  } else {
    // Here value: number
    console.log(value.toFixed(2));
  }
}
```

Every condition that can refine the type—`typeof`, `instanceof`, `in`, equality checks, or even `if (value)`—narrows what TypeScript believes is inside.

---

#### `typeof`

Used for primitive types (`string`, `number`, `boolean`, `symbol`, `undefined`, `bigint`).

```ts
if (typeof input === "boolean") { /* input: boolean */ }
```

---

#### `instanceof`

Used for class or constructor-based checks.

```ts
if (error instanceof Error) { console.error(error.message); }
```

---

#### `in` operator

Used for checking property existence; narrows union members that define that property.

```ts
type Circle = { kind: "circle"; radius: number };
type Square = { kind: "square"; side: number };
type Shape = Circle | Square;

function area(shape: Shape) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2; // Circle
  } else {
    return shape.side ** 2; // Square
  }
}
```

---

#### **Discriminated unions**

This is the *canonical* TypeScript narrowing technique. Each member of the union has a **discriminant** — a literal property that identifies which one it is.

```ts
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number }
  | { kind: "triangle"; base: number; height: number };

function area(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    case "triangle":
      return (shape.base * shape.height) / 2;
    default:
      // 'never' ensures exhaustive coverage
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}
```

The `kind` property is the **discriminant**, and it lets TypeScript narrow automatically inside each branch.

---

#### **Custom type guards**

You can define your own reusable narrowing logic.

```ts
function isCircle(shape: Shape): shape is { kind: "circle"; radius: number } {
  return shape.kind === "circle";
}

if (isCircle(s)) {
  // s is now narrowed to Circle
}
```

---

### 💬 Interview-ready answer

> Narrowing is how TypeScript refines the possible type of a variable as your code runs through checks.
>
> It’s driven by control flow — the compiler watches conditions like `typeof`, `instanceof`, and `in` to automatically limit what a variable can be.
>
> For example, with a union type, a check like `if (typeof value === 'string')` narrows that branch to just `string`.
>
> Discriminated unions take that further by giving each union member a shared literal property (like `kind: "circle"`) that TypeScript uses to infer exactly which shape you’re in.
>
> You can also write your own type guards that return `value is Type` for more complex cases.
>
> Altogether, narrowing is what lets you safely handle flexible data while staying type-safe and expressive.

---

Next up: **Q5 – Union vs intersection types: practical differences and pitfalls?**
This one builds beautifully from what you just covered.
