# 3. **Structural typing:** Explain with an example where it helps and where it bites (excess property checks, accidental compatibility).

## a

I am not versed on this. Please help

## A

Good — that’s honest, and you’re not alone. Structural typing is one of the least understood but most *fundamental* ideas behind TypeScript. It’s what makes TS “JavaScript with types” instead of a whole new language.

Let’s demystify it.

---

### 🧠 What it means

TypeScript uses **structural typing**, sometimes called *“duck typing with static checks.”*
If two types have the same **shape** — the same properties with the same types — then they’re considered *compatible*, even if they were declared separately.

By contrast, a **nominal type system** (like in Java, Rust, or Swift) would require explicit declarations that two types are the same kind.

---

### ✅ Where it helps

It makes TypeScript wonderfully *flexible* and easy to integrate into existing JavaScript.

```ts
interface Point2D {
  x: number;
  y: number;
}

interface Pixel {
  x: number;
  y: number;
}

function draw(p: Point2D) { /* ... */ }

const pixel: Pixel = { x: 10, y: 20 };
draw(pixel); // ✅ Works — same shape, different name
```

Here, even though `Point2D` and `Pixel` are unrelated, TypeScript says “hey, they both walk and quack like `{ x: number, y: number }` — good enough!”

That’s *structural compatibility*.

It’s why TypeScript plays nicely with JavaScript libraries — you don’t need to explicitly mark every external object as implementing a specific interface.

---

### ⚠️ Where it bites

Structural typing can backfire when you want **nominal** distinctions — when different entities happen to have the same shape but shouldn’t be interchangeable.

```ts
interface User { id: string }
interface Product { id: string }

function getUser(u: User) { /* ... */ }

const product: Product = { id: "P-123" };
getUser(product); // 😬 Compiles fine! same shape.
```

This can lead to subtle logic bugs because TypeScript only sees structure, not intent.

To fix this, people use **branding** or **opaque types**:

```ts
type UserId = string & { __brand: 'UserId' };
type ProductId = string & { __brand: 'ProductId' };

function getUser(id: UserId) {}
const userId = "U-123" as UserId;
getUser(userId); // ✅
getUser("P-123" as ProductId); // ❌ Type error now
```

---

### 🧪 Excess property checks

One small exception to this flexibility: when you create an **object literal** inline, TS performs an *excess property check*. This is meant to catch typos early.

```ts
interface User { name: string }

const user: User = { name: "Cher", age: 3 } 
// ❌ Error: Object literal may only specify known properties
```

But if you assign that literal to a variable first, the check loosens:

```ts
const temp = { name: "Cher", age: 3 }
const user: User = temp; // ✅ Works — shape compatibility only
```

This is TS trying to protect you from typos while still supporting JS’s flexibility.

---

### 💬 Interview-ready answer

> TypeScript uses **structural typing**, meaning compatibility is based on the *shape* of a value rather than its declared name.
>
> This is great for JavaScript interop — if an object has the right fields, it just works, even if it comes from another module or library.
>
> But it can also cause **accidental compatibility**, where two unrelated types with the same shape are treated as interchangeable. That’s why we sometimes use branded types to enforce nominal distinctions.
>
> The main gotcha is **excess property checking** — when using object literals, TypeScript is stricter to prevent typos, but once assigned to a variable, the structural rules apply again.

---

Want to move on to **Q4: Narrowing** next? It’s a really practical one and builds naturally from this.
