# 3. **Structural typing:** Explain with an example where it helps and where it bites (excess property checks, accidental compatibility).

## a

I am not versed on this. Please help

## A

Good â€” thatâ€™s honest, and youâ€™re not alone. Structural typing is one of the least understood but most *fundamental* ideas behind TypeScript. Itâ€™s what makes TS â€œJavaScript with typesâ€ instead of a whole new language.

Letâ€™s demystify it.

---

### ðŸ§  What it means

TypeScript uses **structural typing**, sometimes called *â€œduck typing with static checks.â€*
If two types have the same **shape** â€” the same properties with the same types â€” then theyâ€™re considered *compatible*, even if they were declared separately.

By contrast, a **nominal type system** (like in Java, Rust, or Swift) would require explicit declarations that two types are the same kind.

---

### âœ… Where it helps

It makes TypeScript wonderfully *flexible* and easy to integrate into existing JavaScript.

```ts
interface Point2D {
  x: number;
  y: number;
}

interface Pixel {
  x: number;
  y: number;
}

function draw(p: Point2D) { /* ... */ }

const pixel: Pixel = { x: 10, y: 20 };
draw(pixel); // âœ… Works â€” same shape, different name
```

Here, even though `Point2D` and `Pixel` are unrelated, TypeScript says â€œhey, they both walk and quack like `{ x: number, y: number }` â€” good enough!â€

Thatâ€™s *structural compatibility*.

Itâ€™s why TypeScript plays nicely with JavaScript libraries â€” you donâ€™t need to explicitly mark every external object as implementing a specific interface.

---

### âš ï¸ Where it bites

Structural typing can backfire when you want **nominal** distinctions â€” when different entities happen to have the same shape but shouldnâ€™t be interchangeable.

```ts
interface User { id: string }
interface Product { id: string }

function getUser(u: User) { /* ... */ }

const product: Product = { id: "P-123" };
getUser(product); // ðŸ˜¬ Compiles fine! same shape.
```

This can lead to subtle logic bugs because TypeScript only sees structure, not intent.

To fix this, people use **branding** or **opaque types**:

```ts
type UserId = string & { __brand: 'UserId' };
type ProductId = string & { __brand: 'ProductId' };

function getUser(id: UserId) {}
const userId = "U-123" as UserId;
getUser(userId); // âœ…
getUser("P-123" as ProductId); // âŒ Type error now
```

---

### ðŸ§ª Excess property checks

One small exception to this flexibility: when you create an **object literal** inline, TS performs an *excess property check*. This is meant to catch typos early.

```ts
interface User { name: string }

const user: User = { name: "Cher", age: 3 } 
// âŒ Error: Object literal may only specify known properties
```

But if you assign that literal to a variable first, the check loosens:

```ts
const temp = { name: "Cher", age: 3 }
const user: User = temp; // âœ… Works â€” shape compatibility only
```

This is TS trying to protect you from typos while still supporting JSâ€™s flexibility.

---

### ðŸ’¬ Interview-ready answer

> TypeScript uses **structural typing**, meaning compatibility is based on the *shape* of a value rather than its declared name.
>
> This is great for JavaScript interop â€” if an object has the right fields, it just works, even if it comes from another module or library.
>
> But it can also cause **accidental compatibility**, where two unrelated types with the same shape are treated as interchangeable. Thatâ€™s why we sometimes use branded types to enforce nominal distinctions.
>
> The main gotcha is **excess property checking** â€” when using object literals, TypeScript is stricter to prevent typos, but once assigned to a variable, the structural rules apply again.

---

Want to move on to **Q4: Narrowing** next? Itâ€™s a really practical one and builds naturally from this.
