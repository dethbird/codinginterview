# **Type aliases vs interfaces:** Where are they interchangeable, where do they differ (merging, recursion, unions), and how do you choose?

## a

Aliases are another name for an existing type. They can be merged or used in a union. Interfaces are not yet implemented and so can't be used in type maths. Both can be used as function parameters or prop types as long as they have the same properties and methods. That's my best answer please help.

## A

Nice startâ€”youâ€™re circling the core idea: **aliases name types**, **interfaces describe shapes**. Youâ€™ve also hinted at one of the biggest distinctions (interfaces can merge). Letâ€™s sharpen and fill in whatâ€™s missing.

---

### âœ… What you got right

* Type aliases *name a type*; theyâ€™re a kind of shorthand.
* Both interfaces and type aliases can represent object shapes and can be used for props, parameters, etc.
* Both are compatible through **structural typing** (if two shapes match, theyâ€™re interchangeable).

---

### âš ï¸ What you missed / need to fix

* Interfaces **can merge**; type aliases **cannot**.
* Type aliases can represent **anything** â€” primitives, unions, intersections, mapped types, conditional types â€” not just objects.
* Interfaces are **open** (extensible); type aliases are **closed** (once defined, cannot be augmented).
* Recursive type definitions sometimes need to use one or the other depending on context. Interfaces handle recursive object types more elegantly; aliases sometimes require wrapping in a reference (`type Foo = Foo[]` can be problematic).
* â€œInterfaces are not yet implementedâ€ â€” thatâ€™s off. Theyâ€™re fully implemented at compile-time only; they donâ€™t exist at runtime (neither does a type alias).

---

### ðŸ§  Technical details

| Feature                    | **Interface**                                               | **Type Alias**                                    |
| -------------------------- | ----------------------------------------------------------- | ------------------------------------------------- |
| **Extensibility**          | Can be merged or extended via `extends`                     | Cannot merge; can compose via intersections (`&`) |
| **Usage**                  | Only for object-like shapes                                 | Any type (objects, unions, primitives, etc.)      |
| **Declaration merging**    | âœ… Yes â€” repeated declarations merge                         | âŒ No                                              |
| **Extends / Implements**   | âœ… Classes can implement them                                | âœ… (via intersection type, not `implements`)       |
| **Unions / Intersections** | âŒ Cannot form unions                                        | âœ… Can easily create unions/intersections          |
| **Recursion**              | Works well in self-referential structures                   | Works, but sometimes needs wrapping tricks        |
| **Performance**            | Slightly better in tooling due to simpler shape constraints | Can get slow in complex conditional types         |

Examples:

```ts
// Interface: object-only, extendable
interface Animal { name: string; }
interface Dog extends Animal { bark(): void; }
interface Animal { age?: number; } // merges! (declaration merging)

// Type alias: flexible, composable
type Animal = { name: string };
type Dog = Animal & { bark(): void };
type Pet = Dog | Cat; // union â€“ not possible with interfaces
```

And merging:

```ts
interface ApiResponse { status: number }
interface ApiResponse { data: unknown }
// merges â†’ { status: number; data: unknown }

type ApiResponse = { status: number }
// type ApiResponse = { data: unknown } // âŒ Error: duplicate identifier
```

---

### ðŸ’¬ Interview-ready answer

> Interfaces and type aliases both describe the shape of data, and in many cases theyâ€™re interchangeable.
>
> The key differences are:
>
> * **Interfaces are open**: they can be extended or declaration-merged, which is handy for library authors and class contracts.
> * **Type aliases are closed**: they canâ€™t merge, but theyâ€™re more flexible â€” they can represent primitives, unions, intersections, or even conditional types.
>
> I usually prefer **interfaces** for object shapes and public APIs that may need extension, and **type aliases** for composition, unions, and complex type expressions. The distinction is mostly about flexibility vs extensibility.

---

Ready for **Q3: Structural typing** next? That oneâ€™s great because it ties everything together.
