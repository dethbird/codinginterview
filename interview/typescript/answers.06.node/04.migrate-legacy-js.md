# 30. **Working with legacy JS:** Strategies to add TS incrementally, ambient types, `d.ts` authoring basics.

## a

## A

Perfect — this last one ties the entire TypeScript journey together.
Most mid–senior roles expect you to know how to **introduce TypeScript gradually** into a mixed JS codebase, how to **safely type “legacy” JS modules**, and how to **author or patch type declarations** when third-party libraries don’t provide good ones.

---

## 30. Working with legacy JS & ambient types

### A) The core problem

You inherit a repo that’s 80% plain JavaScript — dozens of `.js` files, `require()` calls, and missing or wrong types for third-party packages.
Your job: migrate **incrementally** without breaking builds or DX.

---

### B) Step 1 — Turn on “allowJs” and “checkJs”

In `tsconfig.json`:

```json
{
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "maxNodeModuleJsDepth": 2,
    "strict": true,
    "noImplicitAny": true
  },
  "include": ["src"]
}
```

Now `.js` files are parsed by TypeScript.
Annotate with **JSDoc comments** for lightweight typing:

```js
// user.js
/**
 * @typedef {{ id: string, name: string }} User
 */

/**
 * @param {User} user
 * @returns {string}
 */
export function greet(user) {
  return `Hello ${user.name}`;
}
```

VS Code autocompletion now works, and the compiler flags mistakes — no `.ts` rewrite yet.

---

### C) Step 2 — Gradual migration

Rename a file to `.ts` (or `.tsx`), fix the top few errors, move on.
When you rename:

1. Add missing imports (`import type` helps avoid runtime cost).
2. Fix implicit anys.
3. Replace CommonJS with ESM gradually:

   ```js
   // old
   const util = require("./util");
   module.exports = fn;
   // new
   import util from "./util";
   export default fn;
   ```

---

### D) Step 3 — Ambient type declarations (`.d.ts`)

When a library has **no types** (or bad ones), write your own minimal declarations.

Example: a legacy analytics SDK on `window.Analytics`:

```ts
// analytics.d.ts
declare global {
  interface Window {
    Analytics: {
      track(event: string, props?: Record<string, unknown>): void;
    };
  }
}

export {}; // ensure this file is a module
```

Now in any file:

```ts
window.Analytics.track("Signup");
```

If a library is imported:

```ts
// types/my-lib/index.d.ts
declare module "my-lib" {
  export function doThing(x: number): string;
}
```

Then in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./types"]
  }
}
```

TypeScript merges it automatically.

---

### E) Step 4 — Use `declare` & `interface merging`

Interfaces in the same scope **merge** — ideal for extending third-party types.

Example: augment Express’s `Request` to add `user`:

```ts
// express.d.ts
import "express";
declare module "express-serve-static-core" {
  interface Request {
    user?: { id: string; email: string };
  }
}
```

No runtime change — just compile-time context.

---

### F) Step 5 — Typing untyped modules (`any` isn’t evil, just transitional)

If something’s hopelessly dynamic:

```ts
declare module "legacy-parser" {
  const parse: (input: string) => any;
  export default parse;
}
```

You’ve fenced off the danger.
Later, replace `any` with specific shapes as you gain confidence.

---

### G) Step 6 — `@ts-expect-error` and `@ts-ignore`

Prefer `@ts-expect-error`:

```ts
// @ts-expect-error legacy library returns nonsense
legacyFn(42);
```

It fails the build if the error ever disappears, so it’s *self-healing*.
`@ts-ignore` silently suppresses — use rarely.

---

### H) Step 7 — Publish your own types

When you refactor a legacy lib into its own package:

* Put `.d.ts` files under `types/` or inline in `src/`.
* Add `"types": "dist/index.d.ts"` to `package.json`.
* Use `tsup`, `tsc`, or `rollup-plugin-dts` to emit bundled declarations.

---

### I) Step 8 — Strategies for hybrid stacks

* **Front + back share models:** move only the shared ones into a `types/` package.
* **Runtime validation** (Zod, Valibot): generate `.d.ts` from schema if you can’t refactor the runtime yet.
* **Third-party JS config** (webpack, vite): keep config files JS + JSDoc-typed to avoid runtime loading issues.

---

### J) Interview-ready answer

> In mixed JS/TS codebases, I migrate incrementally. I start with `allowJs` + `checkJs` to lint JS via the compiler, using JSDoc typedefs for quick wins. Then I rename files to `.ts` gradually, fix implicit `any`, and replace `require()` with ESM imports.
>
> For untyped dependencies I write **ambient `.d.ts` files** under `types/`, sometimes extending library declarations via **module augmentation** (e.g. adding `req.user` to Express). I prefer `@ts-expect-error` over `@ts-ignore` to keep suppression temporary.
>
> The goal is continuous adoption: TypeScript at the boundaries first (API layers, utilities) and full static coverage as confidence grows — without a big-bang rewrite.

---

That completes the TypeScript theory set — from the primitives through advanced generics, runtime validation, and real-world integration.
Want to pivot next into the **practical coding** questions (small exercises you could see in a real interview, e.g. “write a typed debounce” or “implement a generic `groupBy<T>`”)?
