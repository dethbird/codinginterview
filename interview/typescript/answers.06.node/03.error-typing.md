# 29. **Error typing & async:** `unknown` errors, `Promise` utilities (`Awaited`, `Thenable`), and typed `try/catch`.

## a

## A

Let’s make async/error typing feel crisp instead of haunted. Three pillars:

1. **Errors are `unknown`** (on purpose)
2. **Model outcomes explicitly** (unions/`Result`)
3. **Use the async helpers correctly** (`Awaited`, `PromiseLike`, etc.)

---

## 29. Error typing & async

### A) `unknown` errors (and how to tame them)

Since TS 4.4, `catch (e)` is `unknown`. That’s good: anything can be thrown.

**Narrowing helpers:**

```ts
function isError(e: unknown): e is Error {
  return e instanceof Error || (typeof e === "object" && e !== null && "message" in e);
}

function messageFrom(e: unknown): string {
  return isError(e) ? e.message : String(e);
}
```

**Typed try/catch pattern:**

```ts
async function loadUser(id: string) {
  try {
    const res = await fetch(`/api/users/${id}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return (await res.json()) as { id: string; name: string };
  } catch (e) {
    // e: unknown
    console.error("loadUser failed:", messageFrom(e));
    throw e; // preserve original (or wrap with cause)
  }
}
```

> Tip: When you rethrow, consider `new Error("context", { cause: e as unknown })` (Node 16+/modern runtimes) for breadcrumbs.

---

### B) Discriminated `Result` instead of exceptions

Avoid “exceptions as control flow” at call-sites. Return a **discriminated union**:

```ts
type Ok<T>   = { ok: true;  data: T };
type Fail<E> = { ok: false; error: E };
type Result<T, E = Error> = Ok<T> | Fail<E>;

async function getUser(id: string): Promise<Result<{id: string; name: string}, Error>> {
  try {
    const r = await fetch(`/api/users/${id}`);
    if (!r.ok) return { ok: false, error: new Error(`HTTP ${r.status}`) };
    return { ok: true, data: await r.json() };
  } catch (e) {
    return { ok: false, error: isError(e) ? e : new Error(String(e)) };
  }
}

// call-site:
const r = await getUser("1");
if (!r.ok) return toast.error(r.error.message); // fully typed
show(r.data.name);
```

This keeps consumers from sprinkling `try/catch` everywhere and gives IntelliSense on both paths.

---

### C) `Awaited`, `Thenable`, and friends

* **`Awaited<T>`** resolves the *eventual* value of a promise (recursively).

  ```ts
  type Data = Awaited<ReturnType<typeof loadUser>>; // inferred resolved type
  ```

* Works with **`Promise`** and **thenables** (objects with `.then()`):

  ```ts
  type Unwrapped<T> = Awaited<T>; // handles Promise<T> | T | Thenable<T>
  ```

* Handy for helpers that accept sync or async:

  ```ts
  type MaybePromise<T> = T | Promise<T>;
  type Settled<T> = Awaited<MaybePromise<T>>;
  ```

**Parallel patterns (typed):**

```ts
const [user, posts] = await Promise.all([
  getUser("1"),              // Result<User, Error>
  getPosts("1")              // Result<Post[], Error>
] as const);
// tuple inference stays precise via `as const`
```

**`Promise.allSettled` typed narrowing:**

```ts
const results = await Promise.allSettled([fetchA(), fetchB()] as const);
for (const r of results) {
  if (r.status === "fulfilled") r.value; // typed
  else r.reason; // unknown → narrow like errors
}
```

---

### D) Expressing “this throws” vs “this returns Result”

Pick one per API surface.

* **Throwing style** (good for leaf functions, wrap at boundary):

  ```ts
  async function mustGetUser(id: string): Promise<User> { /* may throw */ }
  ```

* **Result style** (good for top-level orchestration / UI handlers):

  ```ts
  async function tryGetUser(id: string): Promise<Result<User, Error>> { /* no throw */ }
  ```

You can adapt between them at boundaries (wrap or unwrap once).

---

### E) Extra niceties (brief)

* **Narrow HTTP/Domain errors** with a discriminant:

  ```ts
  type HttpError = { kind: "http"; status: number; message: string };
  type ParseError = { kind: "parse"; message: string };
  type DomainError = HttpError | ParseError;
  ```

* **Map unknown → Error** immediately at the boundary so inner code stays clean.

* **Abort signals**: keep in your function signature; aborted fetches throw `DOMException` with `name === "AbortError"`—narrow it.

```ts
catch (e) {
  if (e instanceof DOMException && e.name === "AbortError") return { ok:false, error: e };
}
```

---

## Interview-ready answer (tight)

> In modern TS, `catch` binds `unknown`, which forces you to **narrow** errors intentionally. I keep a tiny helper like `isError(e): e is Error` or `messageFrom(e)` so I can log or display safely.
>
> For async flows, I prefer a **discriminated `Result`** (`{ ok: true; data } | { ok: false; error }`) at the edges; it makes call-sites explicit and avoids exception-based control flow. Inside leaf functions I may throw and then **adapt** to `Result` at the boundary.
>
> I use `Awaited<T>` to derive the resolved type of promises and handle thenables uniformly. For concurrency (`Promise.all` / `allSettled`), I use `as const` to keep tuple inference sharp and narrow the settled results by their `status`.
>
> Net effect: unknown errors are narrowed, outcomes are explicit, and async types remain precise without scattering `any` or unsafe casts.

---

If you want, we can finish the set with **Q30 – Working with legacy JS: incremental TS, ambient types, and authoring `.d.ts`**; or jump to a practical like adding `Result` + `messageFrom()` to your fetch layer and I’ll tune it for your stack.
