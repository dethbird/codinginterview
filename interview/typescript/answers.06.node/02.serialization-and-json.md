# 28. **Serializability & JSON:** What is (and isn’t) JSON-safe? How to express `JsonValue` types.

## a

## A

Deliciously practical. “JSON-safe” trips up even seasoned folks. Let’s pin down **what is (and isn’t) serializable**, express it **precisely in TypeScript**, and add a few guardrails you can drop into real apps.

---

## 28. Serializability & JSON: what’s actually allowed?

**JSON allows only:**

* Primitives: `string`, `number` (finite), `boolean`, `null`
* Arrays of JSON values
* Objects with **string keys** and JSON values

**Not allowed / lossy or rejected:**

* `undefined` (dropped in objects, becomes `null` in arrays via replacer hacks)
* `NaN`, `Infinity`, `-Infinity` (stringify → `"null"`)
* `BigInt` (throws), `Symbol`, `Function`, `Date` (stringified ISO, but loses type), `Map/Set`, class instances, circular refs

Redux, React Server Components, and many persistence layers expect **JSON-serializable** data. That’s why this matters.

---

## Precise TypeScript types for JSON

```ts
export type JsonPrimitive = string | number | boolean | null;

export type JsonValue =
  | JsonPrimitive
  | JsonObject
  | JsonArray;

export interface JsonObject {
  [k: string]: JsonValue; // string keys only
}

export interface JsonArray extends Array<JsonValue> {}
```

Bonus: a **readonly** version (nice for constants / RSC):

```ts
export type ReadonlyJsonValue =
  | JsonPrimitive
  | { readonly [k: string]: ReadonlyJsonValue }
  | readonly ReadonlyJsonValue[];
```

Use these to lock function inputs/outputs:

```ts
function save(key: string, value: JsonValue): void { /* ... */ }
function load(key: string): JsonValue | null { /* ... */ }
```

---

## Runtime guards (because types vanish at runtime)

A tiny validator:

```ts
export function isJsonValue(x: unknown): x is JsonValue {
  if (x === null) return true;
  const t = typeof x;
  if (t === "string" || t === "number" || t === "boolean") return true;
  if (Array.isArray(x)) return x.every(isJsonValue);
  if (t === "object") {
    for (const [k, v] of Object.entries(x as Record<string, unknown>)) {
      if (typeof k !== "string" || !isJsonValue(v)) return false;
    }
    return true;
  }
  return false;
}
```

Zod flavor (schema + inferred type):

```ts
import { z } from "zod";

export const JsonSchema: z.ZodType<JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number().finite(),
    z.boolean(),
    z.null(),
    z.array(JsonSchema),
    z.record(JsonSchema), // string keys only
  ])
);
```

---

## Practical pitfalls & how to handle them

* **`Date`**: serialize as ISO and rehydrate with a reviver or library.

  ```ts
  const s = JSON.stringify({ at: new Date().toISOString() });
  const parsed = JSON.parse(s, (k, v) =>
    typeof v === "string" && /^\d{4}-\d{2}-\d{2}T/.test(v) ? new Date(v) : v
  );
  ```

  Or adopt a convention: `{ _type: "Date", value: string }`.

* **`BigInt`**: JSON doesn’t support it. Either:

  * convert to string: `{ amount: big.toString() }`, or
  * use a custom serializer (`superjson`, `devalue`) if your stack allows.

* **`undefined`**:

  * Objects: dropped by `JSON.stringify`. Prefer `null` to express “explicitly empty”, or omit the key to express “unknown”.
  * Arrays: `undefined` becomes `null` only if you custom-replace; otherwise it becomes `null` when round-tripped inconsistently—avoid.

* **`NaN` / `Infinity`**: use a sentinel (e.g., `null` or string `"NaN"`) or schema that rejects them (`z.number().finite()` as above).

* **Class instances / Maps / Sets**:

  * Normalize to JSON first (e.g., `Object.fromEntries(map)` / `Array.from(set)`).
  * Rehydrate via explicit constructors after parse.

* **Circular references**: vanilla JSON can’t. Use a library (flatted) or break cycles.

---

## Safer APIs: “boundary layer” pattern

Validate once at the edge, then trust inside:

```ts
// incoming request body
const payload = await req.json();
if (!JsonSchema.safeParse(payload).success) {
  return res.status(400).json({ error: "Invalid JSON payload" });
}
// past this line, treat `payload` as JsonValue
```

And for storage:

```ts
function persist(key: string, value: JsonValue) {
  localStorage.setItem(key, JSON.stringify(value));
}
```

---

## Redux / server-state tips

* **Redux serializable check**: keep slice state `JsonValue`-compatible. If you must store non-JSON (e.g., `Date`), either:

  * store ISO strings and parse in selectors, or
  * customize the serializable middleware to whitelist types (trade-offs).
* **TanStack Query** cache: assume JSON-ish; keep fetcher outputs JSON-safe or transform in `select`.

---

## Interview-ready answer (tight)

> JSON-serializable data is restricted to `string | number | boolean | null | { [k: string]: … } | …[]`. I model that precisely in TS with a `JsonValue` recursive type and enforce it at boundaries with a runtime guard or Zod schema that uses `z.number().finite()` and `z.record()`.
>
> Anything else—`Date`, `BigInt`, `Map`, class instances—needs normalization (ISO strings, plain objects, arrays) and explicit rehydration. This matters for Redux and server-rendered environments that require serializable state. I validate at the edge, normalize non-JSON types, and keep the rest of the app working with plain `JsonValue` so I never ship “typed until it hits I/O” bugs.

---

Want to roll into **Q29 – Error typing & async (`unknown`, `Awaited`, typed try/catch`)**, or do a quick **practical**: implement `JsonValue`+`isJsonValue` and I’ll review with test cases?

