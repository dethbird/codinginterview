27. **Typing fetch/axios layer:** End-to-end types for request params and response parsing with runtime guards.

## a

## A

Chef’s kiss topic. Here’s a compact, battle-tested pattern for **typed HTTP clients** that combines TypeScript generics (compile-time) with **runtime guards** (Zod) so you get end-to-end safety for params *and* responses—works the same with `fetch` or Axios.

---

# 1) Route typing (paths + query params)

```ts
// routes.ts
type Id = `${number}`;
type Resource = "users" | "posts";

type IndexRoute = `/${Resource}`;
type ShowRoute  = `/${Resource}/${Id}`;
export type ApiRoute = IndexRoute | ShowRoute;

type ParamNames<S extends string> =
  S extends `${string}:${infer P}/${infer R}` ? P | ParamNames<R> :
  S extends `${string}:${infer P}` ? P :
  never;

export type ExtractParams<S extends string> = { [K in ParamNames<S>]: string };

export function buildPath<R extends string>(
  template: R,
  params: ExtractParams<R>
) {
  return template.replace(/:([A-Za-z0-9_]+)/g, (_, k) => params[k as keyof typeof params]!);
}

// Example:
buildPath("/users/:userId/posts/:postId", { userId: "1", postId: "9" }); // "/users/1/posts/9"
```

---

# 2) Runtime schemas (single source of truth)

```ts
import { z } from "zod";

export const User = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email()
});
export type User = z.infer<typeof User>;

export const UsersPage = z.object({
  items: z.array(User),
  nextCursor: z.string().optional()
});
export type UsersPage = z.infer<typeof UsersPage>;
```

---

# 3) A tiny `fetchJson` with typed input/output + errors

```ts
type HttpMethod = "GET" | "POST" | "PATCH" | "DELETE";
type Json = string | number | boolean | null | { [k: string]: Json } | Json[];

type FetchOptions<B extends Json | undefined> = {
  method?: HttpMethod;
  body?: B;
  signal?: AbortSignal;
  headers?: Record<string, string>;
};

type Ok<T> = { ok: true; data: T };
type Fail<E> = { ok: false; error: E };
type Result<T, E> = Ok<T> | Fail<E>;

type HttpError = { status: number; message: string; details?: unknown };

export async function fetchJson<T, B extends Json | undefined = undefined>(
  url: string,
  schema: z.ZodType<T>,
  opts: FetchOptions<B> = {}
): Promise<Result<T, HttpError>> {
  const { method = "GET", body, headers, signal } = opts;
  const res = await fetch(url, {
    method,
    signal,
    headers: { "Content-Type": "application/json", ...headers },
    body: body === undefined ? undefined : JSON.stringify(body)
  });

  let parsed: unknown = null;
  try { parsed = await (res.status === 204 ? Promise.resolve(null) : res.json()); }
  catch { /* non-JSON or empty */ }

  if (!res.ok) {
    return { ok: false, error: { status: res.status, message: res.statusText, details: parsed } };
  }

  const check = schema.safeParse(parsed);
  if (!check.success) {
    return { ok: false, error: { status: 500, message: "Schema validation failed", details: check.error.flatten() } };
  }

  return { ok: true, data: check.data };
}
```

* **Input typing**: `body` generic `B`.
* **Output typing**: `T` from a **Zod schema**.
* **Error channel**: discriminated union `Result<T, HttpError>`.
* **Abortable** via `signal`.

---

# 4) Ergonomic API client (paths + query building)

```ts
const q = (obj?: Record<string, string | number | boolean | undefined>) =>
  obj ? "?" + new URLSearchParams(
    Object.entries(obj).reduce<Record<string, string>>((acc, [k, v]) => {
      if (v !== undefined) acc[k] = String(v);
      return acc;
    }, {})
  ).toString() : "";

export class ApiClient {
  constructor(private base = "/api", private defaultHeaders: Record<string, string> = {}) {}

  get<T>(path: string, schema: z.ZodType<T>, query?: Record<string, string | number | boolean>) {
    return fetchJson<T>(`${this.base}${path}${q(query)}`, schema, { headers: this.defaultHeaders });
  }

  post<T, B extends Json>(path: string, schema: z.ZodType<T>, body: B) {
    return fetchJson<T, B>(`${this.base}${path}`, schema, { method: "POST", body, headers: this.defaultHeaders });
  }

  patch<T, B extends Json>(path: string, schema: z.ZodType<T>, body: B) {
    return fetchJson<T, B>(`${this.base}${path}`, schema, { method: "PATCH", body, headers: this.defaultHeaders });
  }

  delete<T>(path: string, schema: z.ZodType<T>) {
    return fetchJson<T>(`${this.base}${path}`, schema, { method: "DELETE", headers: this.defaultHeaders });
  }
}
```

Usage:

```ts
const api = new ApiClient("/api", { Authorization: "Bearer TOKEN" });

// GET /api/users?limit=20
const users = await api.get("/users", UsersPage, { limit: 20 });
if (users.ok) users.data.items; else console.error(users.error);

// POST /api/users
const created = await api.post("/users", User, { name: "Rishi", email: "r@dev.tld" });
```

---

# 5) Typed endpoints with path params

```ts
// e.g. GET /users/:id
async function getUser(id: string) {
  return api.get(buildPath("/users/:id", { id }), User);
}

const r = await getUser("123");
if (r.ok) r.data.email; // fully typed
```

---

# 6) Axios flavor (if your stack prefers it)

Axios adds interceptors and automatic JSON. The typing is similar:

```ts
import axios, { AxiosInstance } from "axios";

export class AxiosClient {
  private http: AxiosInstance;
  constructor(baseURL = "/api") {
    this.http = axios.create({ baseURL });
  }

  async get<T>(url: string, schema: z.ZodType<T>, params?: Record<string, unknown>) {
    try {
      const res = await this.http.get(url, { params });
      const check = schema.safeParse(res.data);
      if (!check.success) throw Object.assign(new Error("Schema fail"), { details: check.error });
      return { ok: true, data: check.data } as Ok<T>;
    } catch (e: any) {
      return {
        ok: false,
        error: { status: e.response?.status ?? 0, message: e.message, details: e.response?.data }
      } as Fail<HttpError>;
    }
  }
}
```

---

# 7) Extras interviewers like to hear

* **Discriminated error unions**: `(ok: true | false)` makes call-sites clean and avoids exceptions in control flow.
* **Exhaustive parsing**: validate **both** success and error payloads when APIs return structured errors.
* **Pagination-safe types**: `nextCursor?: string` or `page: { size; number; total }`.
* **Retries / backoff**: inject a `fetcher` interface so you can swap implementations (native fetch, Node fetch, mock).
* **Testing**: mock at the boundary—supply a fake `fetcher` that returns raw JSON; your schema guards keep tests honest.

---

## Interview-ready answer (say it like this)

> I wrap `fetch` in a small generic function that takes a Zod schema, so the return type is `Result<T, HttpError>`. The schema gives me **runtime validation**, and the generic gives me **static inference**.
> I also type the route layer with template-literal types for paths and a `buildPath()` that enforces param names. Queries are built by a tiny helper that stringifies primitives and omits `undefined`.
> For Redux/TanStack consumers, I export functions like `getUser(id)` that return `Promise<Result<User, HttpError>>`; call-sites narrow on `ok` and never need `as`. This keeps types honest end-to-end and prevents “typed until it hits I/O” bugs.

---

Want to tackle **Q28 – Serializability & JSON types** next, or jump to a practical and I’ll review your version of `fetchJson<T>` with a couple of tests?
