# 1. “Write a test for a component that fetches and paginates. What do you mock vs not?”

## a

I would mock the server so that I could specify the response for each test. The actual fetches need to happen since that will probably be a wrapper that adds context to the request and needs to handle failures properly. Let's say it is cursor based pagination, then I would want to test unreliable responses, things out of sequence etc.  That's all I can think of, can you help.

## A

You’re thinking in the right direction: control the server responses so you can drive the UI. Here’s the calibration first, then clean patterns + pasteable tests.

## What you got right

* ✅ Mock the network so each test can script responses (happy path, errors, weird ordering).
* ✅ Exercise real pagination behavior (e.g., cursor-based, unreliable responses).

## What was missing

* You want to **mock at the boundary** (HTTP) with **MSW**, not mock your data-fetching hooks or components. Keep React Query/Zustand/etc. **real** so you test the real state machine.
* Verify **UI contracts** (loading, disabled buttons, merges/replace of pages, “no more pages”) rather than internal calls.
* Cover race conditions (out-of-order arrivals), aborts/unmounts, and retry/backoff if you have them.
* Only stub **browser APIs** that are noisy (e.g., `IntersectionObserver`) or time (`jest.useFakeTimers`) if your component debounces/infinite-scrolls.

---

## Interview-ready “say it out loud”

**“I mock the network, not my app. I use MSW to intercept HTTP so the component, its hooks, and React Query run for real. That lets me test what users see: loading states, page transitions, disabled ‘Next’ when there’s no `nextCursor`, error recovery, and race conditions. I avoid mocking React Query or my pagination hook because that hides bugs. I only mock platform bits like `IntersectionObserver` or timers when necessary. In short: script server responses with MSW, drive the UI with Testing Library, and assert on DOM + behavior.”**

---

## Minimal example to anchor the tests

**Component (cursor pagination with TanStack Query):**

```tsx
// PaginatedList.tsx
import * as React from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';

type Page = { items: string[]; nextCursor?: string };

async function fetchPage(cursor?: string): Promise<Page> {
  const url = cursor ? `/api/things?cursor=${cursor}` : '/api/things';
  const res = await fetch(url);
  if (!res.ok) throw new Error('Network error');
  return res.json();
}

export function PaginatedList() {
  const qc = useQueryClient();
  const [cursor, setCursor] = React.useState<string | undefined>(undefined);

  const { data, isLoading, isError, refetch, isFetching } = useQuery({
    queryKey: ['things', cursor],
    queryFn: () => fetchPage(cursor),
    keepPreviousData: true, // smoother transitions
  });

  const prefetchNext = React.useCallback(() => {
    if (data?.nextCursor) {
      qc.prefetchQuery({ queryKey: ['things', data.nextCursor], queryFn: () => fetchPage(data.nextCursor) });
    }
  }, [qc, data?.nextCursor]);

  React.useEffect(() => { prefetchNext(); }, [prefetchNext]);

  if (isLoading) return <div aria-label="loading">Loading…</div>;
  if (isError)   return <div role="alert">Could not load</div>;

  return (
    <div>
      <ul>
        {data!.items.map((it) => <li key={it}>{it}</li>)}
      </ul>

      <div aria-live="polite">{isFetching ? 'Updating…' : null}</div>

      <button
        onClick={() => setCursor(data!.nextCursor)}
        disabled={!data!.nextCursor || isFetching}
      >
        Next
      </button>
      <button onClick={() => refetch()}>Reload</button>
    </div>
  );
}
```

---

## Tests (React Testing Library + MSW)

**Test setup:**

```ts
// test/setup.ts
import { setupServer } from 'msw/node';
import { afterAll, afterEach, beforeAll } from 'vitest';
import { handlers } from './testHandlers';

export const server = setupServer(...handlers);

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

**Handlers (script different pages/states):**

```ts
// test/testHandlers.ts
import { http, HttpResponse, delay } from 'msw';

export const handlers = [
  // default: first page
  http.get('/api/things', async () => {
    await delay(50);
    return HttpResponse.json({ items: ['a','b','c'], nextCursor: 'p2' });
  }),
  http.get('/api/things', async ({ request }) => {
    const url = new URL(request.url);
    if (url.searchParams.get('cursor') === 'p2') {
      await delay(50);
      return HttpResponse.json({ items: ['d','e','f'], nextCursor: undefined });
    }
    return undefined as any;
  }),
];
```

**Utility to render with React Query provider:**

```tsx
// test/utils.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { render } from '@testing-library/react';
import React from 'react';

export function renderWithQuery(ui: React.ReactElement) {
  const qc = new QueryClient({ defaultOptions: { queries: { retry: false } } });
  return render(<QueryClientProvider client={qc}>{ui}</QueryClientProvider>);
}
```

**1) Happy path: loads first page, shows next, disables when done**

```tsx
// PaginatedList.test.tsx
import { screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { server } from './setup';
import { http, HttpResponse, delay } from 'msw';
import { renderWithQuery } from './utils';
import { PaginatedList } from '../PaginatedList';

test('loads first page and paginates to end', async () => {
  renderWithQuery(<PaginatedList />);

  // initial loading
  expect(screen.getByLabelText(/loading/i)).toBeInTheDocument();

  // page 1
  await screen.findByText('a');
  expect(screen.getByText('b')).toBeInTheDocument();
  const next = screen.getByRole('button', { name: /next/i });
  expect(next).toBeEnabled();

  // go to page 2
  await userEvent.click(next);
  await screen.findByText('d'); // new page items
  expect(screen.getByRole('button', { name: /next/i })).toBeDisabled(); // no nextCursor
});
```

**2) Error state + recovery**

```tsx
test('shows error, then recovers on reload', async () => {
  // first request fails
  server.use(
    http.get('/api/things', async () => HttpResponse.json({ msg: 'boom' }, { status: 500 }))
  );

  renderWithQuery(<PaginatedList />);
  await screen.findByRole('alert');

  // next request succeeds
  server.use(
    http.get('/api/things', async () => HttpResponse.json({ items: ['x','y'], nextCursor: undefined }))
  );

  await userEvent.click(screen.getByRole('button', { name: /reload/i }));
  await screen.findByText('x');
});
```

**3) Race condition: slow first page resolves after fast second → UI shows the latest**

```tsx
test('handles out-of-order responses (race)', async () => {
  server.use(
    // slow page 1
    http.get('/api/things', async () => {
      await delay(200);
      return HttpResponse.json({ items: ['1','2'], nextCursor: 'p2' });
    }),
    // fast page 2
    http.get('/api/things', async ({ request }) => {
      const url = new URL(request.url);
      if (url.searchParams.get('cursor') === 'p2') {
        await delay(10);
        return HttpResponse.json({ items: ['3','4'], nextCursor: undefined });
      }
      return undefined as any;
    })
  );

  renderWithQuery(<PaginatedList />);
  // Click Next before page 1 resolves (because keepPreviousData rendered the button)
  // To enable this, consider showing Next only when data is present; assume here we can click once loaded.
  await screen.findByText('1');
  await userEvent.click(screen.getByRole('button', { name: /next/i }));

  // Final UI should show page 2 (latest cursor) even if page 1 finishes later.
  await screen.findByText('3');
  expect(screen.queryByText('1')).not.toBeInTheDocument();
});
```

**4) Prefetch is called (optional behavioral assertion)**
You can spy on the second endpoint to ensure prefetching happened when page 1 loaded:

```tsx
test('prefetches next page after first page loads', async () => {
  let prefetchHit = 0;
  server.use(
    http.get('/api/things', async ({ request }) => {
      const url = new URL(request.url);
      if (url.searchParams.get('cursor') === 'p2') {
        prefetchHit++;
        return HttpResponse.json({ items: ['d','e','f'] });
      }
      return undefined as any;
    })
  );

  renderWithQuery(<PaginatedList />);
  await screen.findByText('a');

  await waitFor(() => expect(prefetchHit).toBeGreaterThan(0));
});
```

---

## What to mock vs not (soundbite)

* **Mock:** HTTP boundary with **MSW** (all pages, errors, delays); platform oddities (`IntersectionObserver`, timers) if your component depends on them.
* **Don’t mock:** Your React components, React Query/TanStack logic, or your pagination hook—let them run.
* **Assert:** DOM + behavior (loading, items render, disabled/enabled buttons, retry, no flash on keepPreviousData, race correctness).
* **Edge cases:** empty pages, no `nextCursor`, server 500, network timeout, user navigates away (no setState after unmount).

If you want, I can turn this into a tiny repo scaffold with `vitest`, `@testing-library/react`, and `msw` wired so you can drop in your own component and just write handlers.
