# 3. “What’s your strategy to keep types, tests, and runtime behavior aligned?”

## a 

huh? please help i have no idea.

## A

You’re not alone—this one sounds fuzzy until you translate it to: **“How do you stop TypeScript types, your tests, and the actual running app from drifting apart?”**
Here’s the crisp playbook, then a short “say it out loud” version.

---

## The strategy (senior-level, practical)

### 1) Single source of truth at the **boundaries**

Make schemas the truth; generate everything else from them.

* **HTTP APIs:** OpenAPI/JSON-Schema → generate TS types + client (`openapi-typescript`, `orval`, `rtk-query-codegen`).
* **GraphQL:** SDL/documents → generate TS types + hooks (`graphql-codegen` with fragment masking).
* **DB:** Prisma/Drizzle schema → generate typed client & migrations.
* **Feature flags/config:** a **typed registry** (like we built) exports both runtime defaults and types.

Result: change the schema → types and clients update automatically → tests fail if you didn’t handle the change.

---

### 2) **Runtime validation** mirrors compile-time types

Types alone don’t guard runtime. Parse untrusted inputs at the door.

* Use **Zod**/Valibot on all ingress points (network, env vars, localStorage, feature flags).
* Derive TS types **from** the schema, not vice-versa.

```ts
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  role: z.enum(['admin','user']),
});
export type User = z.infer<typeof UserSchema>;

export async function getUser(): Promise<User> {
  const raw = await fetch('/api/user').then(r => r.json());
  return UserSchema.parse(raw);         // throws if backend drifted
}
```

Now your **runtime behavior** (parsing) and **types** are aligned, and tests can assert on the parser.

---

### 3) Tests target **contracts and invariants**, not implementation trivia

* **Unit**: validate pure logic and invariants (reducers, utils, custom hooks).
* **Integration**: exercise real data flow with **MSW** faking the API using the same schemas.
* **E2E**: assert critical journeys; optionally validate network responses against Zod to catch backend drift.

```ts
// integration example
server.use(http.get('/api/user', () => HttpResponse.json({ id: 'bad', email: 'x', role: 'cat' })));
await expect(getUser()).rejects.toThrow(/Invalid/); // drift caught
```

Add **property-based tests** (`fast-check`) for core invariants where shapes vary.

---

### 4) CI gates that prevent drift

* `tsc --noEmit` (typecheck), ESLint, `ts-prune` (dead exports).
* **Schema drift checks**: generate clients in CI and fail if diff exists uncommitted.
* Run **migrations** in CI (`prisma migrate deploy --schema …`) to ensure DB + types stay in lockstep.
* **Changesets** for versioning; require semver bumps when APIs/types change.

---

### 5) Keep types close to the thing they describe

* Public library API → `@acme/types` (shared package).
* Feature-local types live with the feature; don’t export internal noise.
* For React, type the **boundary**: component props, context values, event payloads. Keep internals flexible.

---

### 6) Observability for reality checks

* In prod, sample **schema parse errors** (guarded, non-crashy) to catch real-world drift early.
* Log feature-flag exposures with the **typed key + value** so analytics can’t silently diverge.

---

## Tiny, end-to-end example (schema → types → runtime → tests)

**Schema is the truth:**

```ts
// schema/user.ts
import { z } from 'zod';
export const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  plan: z.enum(['free','pro','enterprise']),
});
export type User = z.infer<typeof UserSchema>;
```

**Runtime uses the same schema:**

```ts
// api/user.ts
export async function fetchUser(): Promise<User> {
  const raw = await fetch('/api/user').then(r => r.json());
  return UserSchema.parse(raw);
}
```

**Component relies on the typed API (no extra types):**

```tsx
function UserBadge() {
  const { data } = useQuery({ queryKey: ['user'], queryFn: fetchUser });
  if (!data) return null;
  return <span>{data.email} • {data.plan}</span>; // TS ensures plan is one of 3
}
```

**Integration test with MSW validates both behavior and schema:**

```ts
server.use(http.get('/api/user', () => HttpResponse.json({
  id: 'not-a-uuid', email: 'nope', plan: 'gold',
})));
await expect(fetchUser()).rejects.toThrow();  // schema + test aligned
```

Change the schema (e.g., add `name: z.string()`):

* Type breaks in `UserBadge` until you handle it.
* Tests break where mocks don’t include `name`.
* Runtime parse would have caught it in dev/prod.

That’s alignment.

---

## “Say it out loud” (interview-ready)

**“I keep types, tests, and runtime in sync by making the boundary schema the source of truth and generating everything else from it. For HTTP and GraphQL I generate TypeScript types and clients from OpenAPI/SDL, and for the DB I use Prisma/Drizzle so the client types track migrations. At runtime I validate all untrusted inputs with Zod so the app fails fast if the backend or config drifts. Tests focus on contracts: integration tests use MSW with the same schemas, and E2E covers critical journeys. In CI I gate on `tsc`, schema/codegen diffs, and migrations so drift can’t land. Net effect: change the schema and the types, tests, and runtime behavior all evolve together, or the pipeline turns red.”**

If you want, I can spin up a tiny repo skeleton that wires: OpenAPI → generated client/types, Zod runtime parsing, MSW handlers typed from the schema, and a CI script that fails on ungenerated diffs.
