# 1. â€œWalk me through what triggers a re-render. Show how youâ€™d prevent a child from re-rendering when props are stable.â€

## a

State changes trigger a re-render. You can memoize a child so that it only re-render if props actually change.

## A

Perfect â€” this is exactly how you should practice. Letâ€™s polish that into **interview-ready notes**: concise enough to recall under pressure, but deep enough to sound senior-level.

---

## ğŸ§  React Re-render Triggers & Optimization

### What Triggers a Re-render

A React component **re-renders** when:

1. **Its state changes** (`useState`, `useReducer`, etc.).
2. **Its props change** (even if the *new* value is referentially different but *visually identical*).
3. **Its parent re-renders**, and React walks down the tree to determine if child updates are needed.
4. **Context value changes** (via `useContext` or `Context.Consumer`).

Reactâ€™s reconciliation compares the **previous virtual DOM tree** to the **new one**, re-rendering only the components that detect differences in props/state.

---

### Preventing Unnecessary Child Re-renders

When child props are *referentially stable* (same primitive values, same object/function identity), you can use **memoization** to skip re-renders.

#### Example

```jsx
import React, { useState, useCallback, memo } from 'react';

const Child = memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});

export default function Parent() {
  const [count, setCount] = useState(0);

  // âœ… useCallback keeps the same function reference unless `count` changes
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
      <Child onClick={handleClick} />
    </div>
  );
}
```

**Explanation:**

* Without `memo` and `useCallback`, `Child` would re-render every time `Parent` re-renders, because the function prop would have a new reference.
* With `React.memo()` and `useCallback()`, `Child` only re-renders when its actual props change.

---

### Other Optimization Patterns

* **`useMemo`** â€“ memoize expensive calculations so they donâ€™t recompute on every render.
* **`React.memo` with custom comparison** â€“ you can pass a custom `areEqual(prevProps, nextProps)` function to control updates.
* **Avoid creating new objects or arrays inline** (e.g., `{}` or `[]` in JSX), as they create new references each render.

---

### TL;DR for Interviews

> React re-renders when state, props, or context change. To prevent unnecessary re-renders, ensure props are referentially stable and wrap pure components with `React.memo`. Combine with `useCallback` or `useMemo` in the parent to maintain stable references.

---

Would you like me to keep formatting all your future answers like this â€” â€œinterview-level notesâ€ with quick explanation, code example, and TL;DR â€” so you can later compile them into a prep doc?


Good â€” this is where senior-level React understanding really comes into focus. The one-liner summary you quoted is technically correct, but underneath it lies a web of nuance about **referential equality** and **Reactâ€™s reconciliation process**. Letâ€™s break it down piece by piece.

---

## âš™ï¸ Why React Re-renders When "Nothing Changed"

React uses **shallow comparison** to decide if props or state have changed.
That means it checks if `prevProp === nextProp`.

For **primitive values** (like numbers, strings, booleans), this works fine:

```js
prevProp === nextProp // true if same value
```

But for **objects, arrays, and functions**, JavaScript compares **by reference**, not by value:

```js
{} === {} // false
[] === [] // false
() => {} === () => {} // false
```

That means even if two functions or objects *look* identical, theyâ€™re *different references* each render â€” and React thinks the props changed.
Thatâ€™s why your child component re-renders â€œfor no reason.â€

---

## ğŸ§© Stabilizing References with `useCallback` and `useMemo`

These hooks let you **preserve reference identity** across renders, so React sees that a prop hasnâ€™t changed.

---

### `useCallback`: Stable Function References

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  // âŒ new function reference each render:
  // const handleClick = () => console.log('clicked');

  // âœ… useCallback returns the *same* function reference unless dependencies change
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []); // empty dependency array = stable forever

  return (
    <>
      <button onClick={() => setCount(c => c + 1)}>Parent count: {count}</button>
      <Child onClick={handleClick} />
    </>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Child button</button>;
});
```

Hereâ€™s what happens:

* When `Parent` re-renders (because of state change), React checks `Child`â€™s props.
* Because `handleClick` is memoized with `useCallback`, itâ€™s the *same* function reference.
* `React.memo` compares old and new props and sees no difference â†’ skips re-render.

---

### `useMemo`: Stable Object or Array References

If you pass an object or array as a prop, youâ€™ll hit the same issue:

```jsx
function Parent() {
  const [filter, setFilter] = useState('all');

  // âŒ new array every render
  // const items = ['a', 'b', 'c'];

  // âœ… memoized array, stable reference
  const items = useMemo(() => ['a', 'b', 'c'], []);

  return <List items={items} filter={filter} />;
}

const List = React.memo(({ items, filter }) => {
  console.log('List rendered');
  return <ul>{items.map(i => <li key={i}>{i}</li>)}</ul>;
});
```

Without `useMemo`, `List` would re-render every time `Parent` re-rendered â€” even if `items` never *changed* logically.

---

### When to Use These

* **Use `React.memo`** for pure presentational components (render only depends on props).
* **Use `useCallback`** when youâ€™re passing functions down to memoized children.
* **Use `useMemo`** when youâ€™re passing objects or arrays as props.
* Donâ€™t overuse them â€” every memoization adds some overhead. Theyâ€™re best for optimizing *frequently re-rendered trees* or expensive child components.

---

### ğŸ§  Conceptual Summary

| Trigger                   | Example                               | Fix                                    |
| ------------------------- | ------------------------------------- | -------------------------------------- |
| State changes             | `setCount(c + 1)`                     | unavoidable â€” triggers re-render       |
| Props change by value     | `title="Hello"` â†’ `"Hi"`              | unavoidable                            |
| Props change by reference | `{}` / `[]` / `()=>{}` recreated      | use `useMemo` / `useCallback`          |
| Context value changes     | `ThemeContext.Provider value={theme}` | memoize context value or split context |

---

### TL;DR (the expanded version)

> React re-renders when state, props, or context values change.
> For props, React compares references â€” not deep equality â€” so passing new objects or functions causes re-renders even if the data is the same.
> To prevent this, memoize children with `React.memo`, and ensure parent props are **referentially stable** by wrapping functions in `useCallback` and data in `useMemo`. This ensures React sees â€œnothing changedâ€ and skips work.

---

Would you like me to include a diagram version next (showing the render flow of parent â†’ child and how React.memo short-circuits it)? Itâ€™s a great visual for interviews and easy to remember.
