# 3. ‚ÄúWhen would you use `useMemo` vs `React.memo` vs `useCallback`? When *wouldn‚Äôt* you?‚Äù

## a

useMemo is good for when the thing being memo-ized doesn't change much. Like a stable set of props. If it changes a lot, it doesn't really have much effect. useCallback is so that a prop passed as a function is always passed in as the same thing and can be memo-ized. I think it is a new prop everytime otherwise. I don't know where to use React.memo. Or why I wouldn't use these.  

## A


Nice ‚Äî you‚Äôre actually hitting most of the conceptual core here. Let‚Äôs first assess what you already have, then fill in the gaps and finish with an interview-ready explanation.

---

### ‚úÖ What You Got Right

* You correctly identified that `useMemo` and `useCallback` are about **memoizing values** so they don‚Äôt change between renders unless dependencies change.
* You understood that without `useCallback`, **functions get recreated each render** ‚Äî exactly right.
* You also hinted at the **trade-off** (‚Äúif it changes a lot, it doesn‚Äôt really have much effect‚Äù), which shows you get that memoization isn‚Äôt free ‚Äî excellent intuition.

---

### ‚ö†Ô∏è What Was Missing or Incomplete

1. **You mixed up what they each wrap:**

   * `useMemo` memoizes **computed values** (numbers, arrays, objects, JSX, etc.)
   * `useCallback` memoizes **functions**
   * `React.memo` memoizes **entire components** (a higher-order component wrapper)

2. **The ‚Äúwhen not to use them‚Äù part** ‚Äî this is key at senior interviews.

   * Each one adds overhead (memory + dependency tracking).
   * They‚Äôre only worth it if the component or calculation is expensive or causes unnecessary re-renders.
   * Blindly wrapping everything in memoization can *hurt* performance or readability.

3. **`React.memo`‚Äôs purpose** ‚Äî it doesn‚Äôt belong *inside* the component like the hooks do.
   It‚Äôs a wrapper that tells React, *‚ÄúDon‚Äôt re-render me unless my props changed.‚Äù*
   Often used *together* with the other two.

---

### üí° Interview-Ready Explanation

#### `useMemo`

* **What:** Caches the result of an expensive computation between renders.
* **Why:** Avoid recalculating heavy logic or recreating new arrays/objects every render.
* **When not:** If the computation is cheap, skip it ‚Äî memoization overhead might outweigh benefits.

```jsx
const sortedList = useMemo(() => heavySort(data), [data]);
```

---

#### `useCallback`

* **What:** Returns a memoized function reference.
* **Why:** Prevents child components from re-rendering when passed callback props.
* **When not:** If the function isn‚Äôt passed down as a prop or used in a dependency array, don‚Äôt bother.

```jsx
const handleClick = useCallback(() => console.log('clicked'), []);
```

---

#### `React.memo`

* **What:** A higher-order component that memoizes the **render output** of a child component.
* **Why:** Prevents unnecessary re-renders if props haven‚Äôt changed (by shallow comparison).
* **When not:** If the component‚Äôs props always change or the component is already cheap to render.

```jsx
const Child = React.memo(function Child({ onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});
```

---

### üß† How They Work Together

Typical trio pattern:

```jsx
function Parent({ items }) {
  const handleClick = useCallback(() => console.log('click'), []);
  const filteredItems = useMemo(() => items.filter(Boolean), [items]);

  return <Child onClick={handleClick} items={filteredItems} />;
}

const Child = React.memo(({ onClick, items }) => {
  console.log('Child render');
  return <div onClick={onClick}>{items.length}</div>;
});
```

Here:

* `useMemo` keeps `filteredItems` reference stable.
* `useCallback` keeps `handleClick` reference stable.
* `React.memo` prevents `Child` from re-rendering unless one of those props actually changes.

---

### TL;DR

| Hook / API    | Memoizes              | Use it when                                    | Don‚Äôt use it when                           |
| ------------- | --------------------- | ---------------------------------------------- | ------------------------------------------- |
| `useMemo`     | Computed **values**   | Heavy computation or stable object/array props | Cheap computation                           |
| `useCallback` | **Functions**         | Passing callbacks to memoized children         | Function not passed down                    |
| `React.memo`  | **Entire components** | Pure, prop-driven components                   | Props always change or component is trivial |

---

Would you like me to add a quick ‚Äúmental model‚Äù (like: *‚Äú`useMemo` = memoized result, `useCallback` = memoized recipe, `React.memo` = memoized restaurant‚Äù*)? It‚Äôs a memorable analogy interviewers often love.
