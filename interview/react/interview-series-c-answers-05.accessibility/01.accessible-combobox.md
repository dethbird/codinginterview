# 1. “Build an accessible combobox or modal. What ARIA roles are essential?”

## a

I think I just need help on this one. I'm not good at aria stuff.

## A

You got this—ARIA looks scary, but it’s just contracts. I’ll start with your self-assessment, then give you crisp checklists, tiny React snippets, and a short “say it out loud” you can use in interviews.

---

## What you got right

* You knew you needed ARIA but weren’t sure which roles/attrs. Owning the gap is good—accessibility is specific.

## What was missing

* The **exact roles/attributes and keyboard model** for combobox vs modal.
* Focus management: **focus trap** for modals, **active option** management for combobox.
* Relationships: `aria-controls`, `aria-expanded`, `aria-activedescendant`, `aria-labelledby`, `aria-modal`.

---

## Two common widgets: exact ARIA you need

### 1) Combobox (editable autocomplete) — WAI-ARIA 1.2 pattern

Essential roles/attributes:

* **Input:** `role="combobox"`, `aria-autocomplete="list"`, `aria-expanded`, `aria-controls="<listboxId>"`, `aria-activedescendant="<optionId>"` (when a suggestion is highlighted)
* **Popup list:** `role="listbox"`, `id="<listboxId>"`, typically `aria-labelledby` pointing to the input label
* **Items:** `role="option"`, each with unique `id="<optionId>"`
* Optional: `aria-haspopup="listbox"` on the input

Keyboard model (must have):

* **Typing** filters options
* **ArrowDown/ArrowUp** moves the active option
* **Enter** selects active option
* **Escape** closes popup (and clears highlight)
* **Tab** commits current text and closes popup
* Manage **`aria-activedescendant`** on the input to reflect the highlighted option

Minimal React sketch (controlled, listbox popup):

```tsx
function ComboBox({ options }: { options: string[] }) {
  const [open, setOpen] = React.useState(false);
  const [value, setValue] = React.useState('');
  const [activeIndex, setActiveIndex] = React.useState<number | null>(null);
  const listboxId = 'cb-listbox';

  const filtered = options.filter(o => o.toLowerCase().includes(value.toLowerCase()));
  const activeId = activeIndex != null ? `cb-opt-${activeIndex}` : undefined;

  return (
    <div>
      <label id="cb-label" htmlFor="cb-input">City</label>
      <input
        id="cb-input"
        role="combobox"
        aria-labelledby="cb-label"
        aria-autocomplete="list"
        aria-expanded={open}
        aria-controls={listboxId}
        aria-activedescendant={activeId}
        value={value}
        onChange={e => { setValue(e.target.value); setOpen(true); setActiveIndex(null); }}
        onKeyDown={(e) => {
          if (!open && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) setOpen(true);
          if (e.key === 'ArrowDown') setActiveIndex(i => Math.min((i ?? -1) + 1, filtered.length - 1));
          if (e.key === 'ArrowUp') setActiveIndex(i => Math.max((i ?? filtered.length) - 1, 0));
          if (e.key === 'Enter' && activeIndex != null) {
            setValue(filtered[activeIndex]);
            setOpen(false);
          }
          if (e.key === 'Escape') { setOpen(false); setActiveIndex(null); }
        }}
        onBlur={() => { /* consider a short delay if clicking options */ }}
      />

      {open && filtered.length > 0 && (
        <ul role="listbox" id={listboxId}>
          {filtered.map((opt, i) => (
            <li
              key={opt}
              id={`cb-opt-${i}`}
              role="option"
              aria-selected={i === activeIndex}
              onMouseDown={(e) => e.preventDefault()} // keep focus on input
              onClick={() => { setValue(opt); setOpen(false); }}
            >
              {opt}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

Notes:

* Input keeps focus; `aria-activedescendant` points at the active option.
* Use `onMouseDown` preventDefault so clicking options doesn’t blur the input before selection.

---

### 2) Modal dialog

Essential roles/attributes:

* **Container:** `role="dialog"` (or `role="alertdialog"` for destructive confirmations), `aria-modal="true"`, `aria-labelledby="<titleId>"`, optional `aria-describedby="<descId>"`
* **Initial focus** moved into the dialog (e.g., close button or first focusable)
* **Escape** closes (unless critical flow), **Tab/Shift+Tab** are trapped inside
* **Background** should be inert (visually hidden to screen readers). With ARIA: set `aria-hidden="true"` on app root outside dialog, or with modern platforms, use `inert` attribute if supported (plus a polyfill if needed)

Minimal React sketch (focus trap conceptually):

```tsx
function Modal({ open, onClose, title, children }: { open: boolean; onClose: () => void; title: string; children: React.ReactNode }) {
  const titleId = 'modal-title';
  const ref = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (!open) return;
    const prev = document.activeElement as HTMLElement | null;
    // move focus into modal
    ref.current?.querySelector<HTMLElement>('[data-autofocus]')?.focus() ?? ref.current?.focus();
    // escape to close
    const onKey = (e: KeyboardEvent) => { if (e.key === 'Escape') onClose(); };
    document.addEventListener('keydown', onKey);
    return () => { document.removeEventListener('keydown', onKey); prev?.focus(); };
  }, [open, onClose]);

  if (!open) return null;

  return (
    <div role="dialog" aria-modal="true" aria-labelledby={titleId} className="backdrop">
      <div tabIndex={-1} ref={ref} className="modal">
        <h2 id={titleId}>{title}</h2>
        <button onClick={onClose} data-autofocus>Close</button>
        {children}
      </div>
    </div>
  );
}
```

Notes:

* Add a real **focus trap** (e.g., `focus-trap` lib) so Tab stays inside.
* When the modal opens, set `aria-hidden="true"` (or `inert`) on the rest of the app root.

---

## Quick checklists (memory friendly)

**Combobox essentials**

* Input: `role="combobox"`, `aria-autocomplete="list"`, `aria-expanded`, `aria-controls`
* Active option via `aria-activedescendant`
* Popup: `role="listbox"`, items: `role="option"`
* Keys: type filters; ArrowUp/Down move; Enter selects; Escape closes

**Modal essentials**

* Container: `role="dialog"` + `aria-modal="true"`
* Label: `aria-labelledby` (and optional `aria-describedby`)
* Focus: move focus in on open; restore on close; **trap Tab**
* Escape closes; background inert/`aria-hidden`

---

## “Say it out loud” (interview-ready)

**“For an accessible combobox, I follow the ARIA 1.2 pattern: the input has `role="combobox"` with `aria-autocomplete="list"`, `aria-expanded`, `aria-controls` pointing to a `listbox`, and it manages `aria-activedescendant` for the highlighted `option`. Typing filters, arrows move the active option, Enter selects, Escape closes. The input keeps focus; the popup is a `role="listbox"` with `role="option"` items.**

**For a modal, I render a container with `role="dialog"`, `aria-modal="true"`, and `aria-labelledby` that points to the title. I move focus into the dialog on open, trap Tab/Shift+Tab, close on Escape, and mark the rest of the app as inert or `aria-hidden` so screen readers don’t escape. On close I restore focus. That hits the essential ARIA contracts and keyboard model.”**

If you want, I can give you a tiny focus-trap utility and a combobox hook that manages `aria-activedescendant` and keyboard events so you can reuse them across features.
