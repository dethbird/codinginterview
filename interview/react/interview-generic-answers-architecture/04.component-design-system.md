# 5. How would you architect a component library or design system?

## a

    This would start by extracting components already in the application repo as shared into a separate repo. This new repo would contain commonly used components possibly shared across apps. This would become an npm package that can be imported into any application. On top of that, I would use Storybook as a central visual hub for developers and designers to refer to as the source of truth for what's already available and what might need some design effort to create something new.

## A

You‚Äôre thinking in the right direction‚Äîpromote what‚Äôs already working, package it, and give the team a visual source of truth. To make this sing in an interview, add how you handle **tokens, APIs, a11y, builds, versioning, and governance**. Here‚Äôs a tight, Series-C-ready blueprint you can say out loud.

### Goals (one sentence)

A component library should deliver **consistent UI at speed**: accessible by default, themeable via tokens, tree-shakable, versioned, and easy to adopt incrementally.

### Architecture (layers)

1. **Design tokens (source of truth)**

   * Store tokens in JSON (colors, spacing, radii, typography, motion).
   * Compile to CSS variables with Style Dictionary (or similar).
   * Example:

     ```json
     { "color": { "brand": { "500": { "value": "#6b8cff" } } } }
     ```

     ```css
     :root { --color-brand-500: #6b8cff; }
     [data-theme="dark"] { --color-brand-500: #8aa4ff; }
     ```

2. **Primitives & utilities**

   * Low-level building blocks (Box, Stack, Text) that consume tokens.
   * Support **polymorphic `as`** prop when useful.

3. **Components (a11y-first)**

   * Buttons, Inputs, Modal, Menu, Tabs, Combobox, etc.
   * Prefer **compound components** for complex widgets:

     ```tsx
     <Select value=‚Ä¶ onChange=‚Ä¶>
       <Select.Trigger />
       <Select.List>
         <Select.Option value="a" />
       </Select.List>
     </Select>
     ```
   * Offer **controlled + uncontrolled** modes (`value`/`defaultValue`).
   * Bake in keyboard support and ARIA roles; test with `jest-axe`.

4. **Foundations**

   * Icons (one React component per glyph, tree-shakable).
   * Motion primitives with reduced-motion support.
   * RTL mirroring and i18n affordances.

### Project structure (monorepo)

```
ui/
  packages/
    tokens/           # JSON tokens ‚Üí CSS vars, TS types
    react/            # components; peerDeps: react, react-dom
    icons/
    docs/             # Storybook app
  .changeset/         # semantic releases
  tsconfig.base.json
  package.json        # pnpm/yarn workspaces
```

### Build & DX

* **Build:** tsup or Vite to emit **ESM + CJS + types**; mark `"sideEffects": false` for tree-shaking.
* **Styling:** CSS Modules or vanilla-extract, or CSS-in-JS if you need prop-driven variants. All styles consume **CSS variables** from tokens.
* **Storybook:** single source of truth with MDX docs, interactive controls, a11y addon, dark/light toggles.
* **Tests:** RTL + `jest-axe` (a11y), visual regression via Chromatic (or Playwright screenshots).
* **Linting:** `eslint-plugin-react`, `jsx-a11y`, import rules; enforce public API boundaries.
* **CI:** build, typecheck, test, visual review; **Changesets** gates semantic versioning.

### API design guidelines

* **Small, stable props**; avoid prop explosions. Use `variant` + `size` + `tone` for style differences.
* **No implicit globals.** All styling via tokens; no theme hard-codes in components.
* **Escape hatches:** `className`/`style` pass-through for custom tweaks.
* **Accessibility by default:** focus management, roles, `aria-*`, keyboard nav; docs list supported keys.
* **Composition over configuration:** expose subcomponents (`<Modal.Header>`) instead of 25 boolean props.

### Theming & branding

* Runtime theme switch with data-attribute (`data-theme="dark|light|brandX"`).
* App teams can extend tokens (brand overrides) without forking components.
* Support **density** and **motion** tokens for platform needs.

### Versioning, adoption, and governance

* **SemVer** with Changesets; release notes auto-generated per package.
* **Deprecation policy:** mark deprecated props in types + console warning in dev; provide **codemods** for breaking changes.
* **RFCs/ADRs** for major additions; keep contribution guide + playground.
* **Incremental adoption:** publish as an internal npm package; teams can adopt per-component with tree-shaking.

### Migration from app-local components

* Identify duplicates, extract the most robust version, harden a11y, add stories/tests, promote to `ui/react`.
* Replace call sites via codemod; delete local copies; enforce import lint rule to prevent regressions.

### What to say in 20 seconds

> ‚ÄúWe run a tokens-first system: JSON tokens ‚Üí CSS variables, then a11y-first React components built on those tokens. Everything is tree-shakable, typed, and documented in Storybook. We publish from a monorepo with Changesets, enforce small public APIs, and ship controlled/uncontrolled variants. Themes are just token overrides, so brands and dark mode are instant. We migrate incrementally with codemods and a clear deprecation policy.‚Äù

If you want, we can draft a **sample Button API and story** next, or sketch how you‚Äôd implement **Modal with focus trap and `aria-modal`**‚Äîboth popular follow-ups.

    what does tree-shaking mean

Tree-shaking is a fancy name for *dead-code elimination at the module level.*

When you build a modern JavaScript app, tools like **Vite, esbuild, Rollup, or Webpack** analyze your ES module imports (`import { Button } from "@my/ui"`) and remove everything you **didn‚Äôt import** from the final bundle. The metaphor: the build system ‚Äúshakes‚Äù the dependency tree so unused branches fall off.

---

### üîç How it works

1. You write ES modules with **static imports/exports**:

   ```ts
   // ui/index.ts
   export { Button } from "./Button";
   export { Modal } from "./Modal";
   export { Tabs } from "./Tabs";
   ```
2. In your app you import only `Button`:

   ```ts
   import { Button } from "@my/ui";
   ```
3. The bundler sees that `Modal` and `Tabs` are never referenced, so it **omits** them from the compiled bundle.
   The result: smaller JS payload, faster load.

---

### ‚öôÔ∏è Requirements for tree-shaking to work

* **ESM syntax (`import`/`export`)**, not CommonJS (`require`).
* The package marks itself as side-effect-free in `package.json`:

  ```json
  { "sideEffects": false }
  ```

  or lists the files that do have side effects.
* Your build tool is in **production mode** (minifiers like Terser or esbuild remove unused code).

---

### üß© Why it matters for a component library

If your library exports hundreds of components:

```ts
import { Button } from "@company/ui";
```

the consumer‚Äôs bundle will include **only `Button`**, not the entire UI kit.
That‚Äôs crucial for performance and adoption‚Äîteams pay only for what they use.

---

### ‚ö†Ô∏è Common pitfalls

* Using dynamic `require()` or re-exports that execute code breaks static analysis.
* Side-effects at the top level (e.g., `import "./registerIcons"`) prevent pruning.
* CSS imports in JS can also mark files as ‚Äúside-effectful‚Äù; list them explicitly:

  ```json
  { "sideEffects": ["**/*.css"] }
  ```

---

### üó£Ô∏è How to phrase it in an interview

> ‚ÄúTree-shaking means our build only includes code that‚Äôs actually imported. We write ESM, avoid side effects, and mark packages with `"sideEffects": false"`. That way, if a consumer only uses `Button` from our library, the bundler drops the rest, keeping their app bundle small.‚Äù
