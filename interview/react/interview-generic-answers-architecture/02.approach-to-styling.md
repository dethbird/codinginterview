# 2. How do you approach styling (CSS Modules, Styled Components, Tailwind, etc.)?

## a

    I start by using a base stlying framework like Bulma. Components are rendered using that as the framework. If further customization is required, then I start to add CSS files alongside the component and import. App.css would like along App.ts and include overall app styles. However a input type that is not out of the box from the styling framework might need it's own CSS that the rest of the app doesn't need to be concerned with. That component would have a .css file alongside it with styles particular to that component for sizing and positioning.

    For theming, meaning branding colors and logos and fonts, we need to step into built CSS. Most HMR compilers can compile SASS which can use math to calculate color variations based on base theme values.

## A

You’re thinking in the right direction—start with a base, colocate overrides, and keep one-off styles near the component. To make this interview-ready, add (1) a clear **layering model**, (2) **theming via tokens (CSS variables)**, and (3) how you choose between **CSS Modules / Tailwind / CSS-in-JS**. Here’s a tight version you can say out loud, plus a few code crumbs.

### How I structure styling (the 4 layers)

1. **Reset & primitives**: normalize, base typography, spacing scale.
2. **Design tokens** *(CSS variables)*: colors, radii, shadows, font stacks.
3. **Utilities / framework**: Bulma/Tailwind or a small custom utility set.
4. **Components**: styles colocated with the component (CSS Module or styled component), minimal global leakage.

```
src/
  styles/
    tokens.css            # CSS variables (light/dark, brand)
    base.css              # resets, typography, layout primitives
  shared/ui/Button/
    Button.tsx
    Button.module.css     # CSS Module (scoped)
  features/user/…
```

### Theming: tokens first, everything else second

Use **CSS variables** as the “single source of truth” so themes switch instantly without rebuilds.

```css
/* tokens.css */
:root {
  --color-bg: #0b0b0c;
  --color-fg: #eaeaea;
  --brand: #6b8cff;
  --radius: 10px;
}

[data-theme="light"] {
  --color-bg: #ffffff;
  --color-fg: #111;
  --brand: #3a5bff;
}

/* component styles use tokens, not literals */
.card {
  background: var(--color-bg);
  color: var(--color-fg);
  border-radius: var(--radius);
}
.card--accent { border: 2px solid var(--brand); }
```

Then toggle theme at runtime:

```tsx
function ThemeToggle() {
  const on = useToggle(); // boolean
  useEffect(() => {
    document.documentElement.dataset.theme = on ? "light" : "dark";
  }, [on]);
  // …
}
```

This plays well with Bulma, Tailwind, CSS Modules, or styled-components because **tokens are framework-agnostic**.

### Reuse & isolation

* **Colocate** component styles (e.g., `Button.module.css`) to avoid global collisions.
* For Bulma/global frameworks, wrap custom rules in a **block scope** or use **BEM** to keep specificity sane:

  ```css
  /* UserCard.module.css */
  .userCard { /* … */ }
  .userCard__avatar { /* … */ }
  .userCard--compact { /* … */ }
  ```
* Promote shared patterns to `shared/ui` with a small public API; everything else stays local.

### Choosing a styling approach (I explain it like this)

* **CSS Modules**: great default—scoped by class, fast, framework-agnostic.
* **Tailwind**: speed + consistency via utilities; pair with tokens via `:root` or Tailwind theme config; excellent for teams shipping fast.
* **CSS-in-JS (styled-components, Emotion)**: dynamic, prop-driven styles; handy for design systems; tradeoff is bundle/runtime cost.
* **Framework (Bulma/Chakra)**: rapid base, but I still route colors/spacing through tokens so theming isn’t coupled to the framework.

A simple rule I tell interviewers: *“Start with CSS Modules + tokens; move to Tailwind for velocity; use CSS-in-JS when you need prop-driven variants or theming logic.”*

### Performance & DX notes (quick bullets they love)

* **Critical CSS** for above-the-fold; code-split the rest by route.
* Prefer **CSS variables** over SCSS functions for live theming; use **SCSS** only for compile-time maps/mixins.
* Guard against specificity bloat; avoid `!important`.
* **Storybook** to document components in all states (light/dark/RTL/high-contrast); run **axe** checks.
* Keep a **spacing/typography scale** (4/8pt) and **semantic tokens** (`--color-btn-bg`, not `--blue-500`) to survive rebrands.

### A short interview version you can recite

> “I organize by feature with styles colocated next to components. For reuse, I promote stable pieces into `shared/ui` and keep a tiny public API. Theming is token-driven with CSS variables, so switching light/dark/brand is instant at runtime. My default is CSS Modules + tokens; Tailwind for speed on greenfield; CSS-in-JS when I need prop-driven variants. I keep global styles minimal (reset, base), code-split heavy CSS, and validate a11y/contrast in Storybook.”

If you want, next we can hit **routing + code-splitting strategy** or **how you’d architect a component library/design system**—both common Series-C architecture questions.
