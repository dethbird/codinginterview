# 5. How do you integrate GraphQL or REST APIs in React efficiently?

## a

I start with a wrapper around basic http requests. This wrapper is aware of where the access token is stored (in memory). It knows the route for token refresh and calls it if the request it tried to make results in a 401, it can refresh the access token and try the request again. 

Around that I create an API wrapper which knows all the API routes and is able to construct and make authenticated requests. This is useful for if the API changes because in the code you can still say await getUserPlaylists(userId) even though the location of the endpoint has changed.

## A 

You’ve got a solid core: a fetch wrapper with token refresh and a thin API layer of functions like `getUserPlaylists()`. To make this scale in a “frontend-heavy” codebase, layer in **cache management, request de-duping, retries, pagination, and type-safety**—ideally by leaning on proven client libraries.

Here’s an interview-ready blueprint.

### REST: pragmatic + cached

**Use TanStack Query (React Query)** around your fetch wrapper:

* **Server cache ≠ client state.** Keep server data in React Query; keep UI state in React.
* **Query keys** model your resources: `['playlists', userId]`.
* **Smart refetching** with `staleTime`, **retries**, **de-duping**, and background refresh.
* **Mutations** with **optimistic updates** and **invalidation**.

```ts
// fetchBase with refresh-on-401
export async function api(input: RequestInfo, init?: RequestInit) {
  const res = await fetch(input, { ...init, credentials: 'include', headers: { ...init?.headers, Authorization: `Bearer ${getAccessToken()}` }});
  if (res.status === 401 && await tryRefresh()) {
    return fetch(input, { ...init, credentials: 'include', headers: { ...init?.headers, Authorization: `Bearer ${getAccessToken()}` }});
  }
  return res;
}

// React Query usage
function useUserPlaylists(userId: string) {
  return useQuery({
    queryKey: ['playlists', userId],
    queryFn: async () => (await api(`/api/users/${userId}/playlists`)).json(),
    staleTime: 60_000, // 1 min
  });
}
```

**Why this wins:** you keep your nice API wrapper (`getUserPlaylists`) but delegate the gnarly parts—cache, dedupe, retries, window-focus refetch—to a battle-tested library.

### GraphQL: schema-driven and typed

Pick one:

* **Apollo Client**: full-featured (cache policies, pagination helpers, local fields).
* **urql**: lightweight with composable exchanges (retry, auth, multipart fetch, SSR).
* **Relay**: strongest normalization + pagination at scale, but higher ceremony.

**Must-haves:**

* **Codegen types** (`graphql-code-generator`) → typed hooks (`useGetPlaylistsQuery`).
* **Normalized cache** by `id`/`__typename` → consistent updates across views.
* **Pagination policies** (offset vs cursor) configured per field.
* **Auth link** that injects access tokens and handles refresh (single-flight).

```ts
// Apollo auth link + refresh
const authLink = setContext(async (_, { headers }) => {
  let token = getAccessToken();
  if (isExpired(token)) token = await refreshOnce(); // single-flight guard
  return { headers: { ...headers, Authorization: token ? `Bearer ${token}` : '' } };
});

const client = new ApolloClient({
  link: from([authLink, new HttpLink({ uri: '/graphql', credentials: 'include' })]),
  cache: new InMemoryCache({
    typePolicies: {
      Query: {
        fields: {
          playlists: relayStylePagination(), // cursor pagination helper
        },
      },
    },
  }),
});
```

### Cross-cutting efficiency patterns

* **Request de-duping:** React Query/Apollo do this out of the box; don’t reinvent.
* **Batching:** GraphQL supports **query batching** (apollo-link-batch-http) and **automatic persisted queries** to cut payload size.
* **Partial rendering:** Use **Suspense** (or React Query’s `suspense: true`) for clean loading fallbacks; pair with `useTransition` for input-driven queries.
* **Optimistic UI:** Mutations update the cache immediately, roll back on error; show to the interviewer you know this dance.
* **Prefetch on hover/visible:** `queryClient.prefetchQuery()` or Apollo `client.query()` on route hover for snappy nav.
* **WebSockets/subscriptions:** For live data, add a **ws link** (GraphQL) or **SSE**/**WebSocket** channel for REST and **invalidate** affected queries.

### Type-safety & evolvability

* **REST:** Generate TS types from **OpenAPI**; create a typed client.
* **GraphQL:** Generate types + hooks from the schema/operations.
* Keep an **API facade** in your app (`api/users.ts → getUserPlaylists`) so endpoint changes don’t leak into components.

### Error handling & auth details

* Centralize error mapping (HTTP → domain errors) and **surface user-friendly messages**.
* **Single-flight refresh:** ensure only one refresh runs; queue failed requests until it resolves.
* Use **HttpOnly refresh cookie + short-lived access token in memory**; avoid long-lived tokens in localStorage.

### What to say in one breath

> “I wrap fetch with an auth-aware client, but rely on React Query (for REST) or Apollo/urql (for GraphQL) for caching, retries, and de-duping. Data lives in a normalized cache with typed hooks from codegen. I set sensible `staleTime`, prefetch on navigation, and use optimistic mutations with targeted invalidation. Auth refresh is single-flight, tokens are short-lived in memory, and the app calls a stable API facade so endpoint shifts don’t ripple through the UI.”

If you want, we can sketch a **single-flight token refresh helper** or a **Relay-style cursor pagination** example next—both are frequent follow-ups.
