# 3. How do you handle authentication or routing in React?

## a

    I have authentication come in via a JWT when the app loads and instantiate a userContext. This context is small enough but contains relevant user information like roles and permissions. Protected routes are wrapped in a contextProvider from where the userContext can be extracted. The roles and permissions for the user can then be used for protecting routes or re-routing.

## A

You’ve got the skeleton right: context for user/session, route guards for protection, and role/permission checks. To make it interview-ready, add **where the token lives, how it refreshes, and how routing integrates with loading/error states**.

### Auth model (secure & scalable)

* **Token storage:** Prefer **short-lived access tokens in memory** and **refresh tokens in an `HttpOnly`, `Secure`, `SameSite` cookie**. Avoid long-lived JWTs in `localStorage` (XSS risk).
* **Refresh flow:** On app start, call `/session` (or `/refresh`) to obtain an access token if the cookie is present. Rotate on 401 using a single-flight refresh.
* **Authorization data:** Fetch user profile/claims (`roles`, `permissions`, `orgId`) after you have a valid access token and put a **minimal** subset in context.

### React plumbing (clean pattern)

```tsx
// AuthProvider.tsx
import { createContext, useContext, useEffect, useMemo, useState } from "react";

type User = { id: string; roles: string[]; perms: string[] } | null;
type AuthCtx = {
  user: User;
  loading: boolean;
  signIn: (creds: { email: string; password: string }) => Promise<void>;
  signOut: () => Promise<void>;
  has: (perm: string) => boolean;
};

const Ctx = createContext<AuthCtx | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User>(null);
  const [loading, setLoading] = useState(true);

  // On mount, attempt session bootstrap via HttpOnly refresh cookie
  useEffect(() => {
    (async () => {
      try {
        await fetch("/api/refresh", { method: "POST", credentials: "include" }); // set short-lived access token (cookie or header)
        const me = await fetch("/api/me", { credentials: "include" }).then(r => r.ok ? r.json() : null);
        setUser(me);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const signIn = async (creds: { email: string; password: string }) => {
    await fetch("/api/login", { method: "POST", body: JSON.stringify(creds), credentials: "include" });
    const me = await fetch("/api/me", { credentials: "include" }).then(r => r.json());
    setUser(me);
  };

  const signOut = async () => {
    await fetch("/api/logout", { method: "POST", credentials: "include" });
    setUser(null);
  };

  const value = useMemo<AuthCtx>(() => ({
    user,
    loading,
    signIn,
    signOut,
    has: (perm) => !!user?.perms?.includes(perm),
  }), [user, loading]);

  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;
}

export const useAuth = () => {
  const ctx = useContext(Ctx);
  if (!ctx) throw new Error("useAuth must be used within AuthProvider");
  return ctx;
}
```

### Route protection (React Router v6+)

```tsx
// ProtectedRoute.tsx
import { Navigate, Outlet } from "react-router-dom";
import { useAuth } from "./AuthProvider";

export function ProtectedRoute({ requirePerm }: { requirePerm?: string }) {
  const { user, loading, has } = useAuth();

  if (loading) return <div>Checking session…</div>;
  if (!user) return <Navigate to="/login" replace />;

  if (requirePerm && !has(requirePerm)) {
    return <Navigate to="/forbidden" replace />;
  }
  return <Outlet />; // renders child routes
}
```

```tsx
// router.tsx
import { createBrowserRouter } from "react-router-dom";
import { ProtectedRoute } from "./ProtectedRoute";
import Dashboard from "./routes/Dashboard";
import Admin from "./routes/Admin";

export const router = createBrowserRouter([
  {
    element: <ProtectedRoute />, // authenticated area
    children: [
      { path: "/", element: <Dashboard /> },
      { path: "/admin",
        element: <ProtectedRoute requirePerm="admin:access" />, // nested guard
        children: [{ index: true, element: <Admin /> }]
      },
    ]
  },
  { path: "/login", lazy: () => import("./routes/Login") },
  { path: "/forbidden", element: <div>Forbidden</div> },
]);
```

### Nice touches interviewers like

* **Code-split protected routes** (`lazy()` + `<Suspense>`) so logged-out users don’t download private bundles.
* **Global fetch wrapper** that auto-refreshes on 401 (single-flight; queues requests while refreshing).
* **Role vs permission:** Prefer **permissions** (fine-grained, composable) over coarse “roles only.” Cache them and centralize checks (`has()`).
* **SSR/Next.js:** Do auth checks in **server loaders** / middleware for sensitive pages; pass session info as initial props; still hydrate client context.
* **Security knobs:** Cookies with `HttpOnly; Secure; SameSite=Lax/Strict`, CSRF tokens for state-changing requests if you’re on cookie-based auth, and **short TTL** access tokens.

### What to say concisely

> “I bootstrap the session on load using a refresh cookie to mint a short-lived access token, then fetch the user profile and put minimal claims in a context. Routing uses a `ProtectedRoute` that handles the loading state, redirects unauthenticated users, and can enforce permissions. Private areas are code-split. I avoid storing long-lived JWTs in localStorage; instead I rotate tokens and auto-refresh on 401 via a fetch wrapper.”

If you want, we can layer in the **fetch interceptor with single-flight refresh** next, or cover **multi-tenant routing (subdomain/org)** patterns—both are common follow-ups.
