# 1. How do you organize components and hooks for reuse?

## a 

    I organize them by feature. If they are reusable, I put them in a shared folder.

## A

You’re on the right path—**feature-first** is the backbone. To make it interview-ready, add how you enforce *boundaries*, design *public APIs*, and keep reuse *intentional* (not “misc/”). Here’s a crisp, scalable approach.

# Core principles

* **Feature-first, colocation by default.** Code lives with the feature it serves.
* **Promote, don’t pre-abstract.** Only move to `shared/` after 2–3 real reuse cases.
* **Clear public APIs.** Each folder exposes a tiny `index.ts` surface; everything else stays private.
* **Composition over inheritance.** Small components/hooks that compose nicely beat “god” utilities.
* **Strict dependency rules.** Features can depend on `shared`, not the other way around.

# Suggested layout

```text
src/
  app/                          # app shell: routes, providers, global styles
    providers/
    router/
  features/
    user/
      components/
        UserAvatar/
          UserAvatar.tsx
          index.ts              # export { UserAvatar }
          UserAvatar.stories.tsx
          UserAvatar.test.tsx
        UserMenu/
      hooks/
        useUser.ts              # data-fetching hook for user
        useUserPermissions.ts
      utils/
      index.ts                  # export * from './components/...'; export * from './hooks/...'
    cart/
      components/...
      hooks/...
  shared/                       # promoted, reusable building blocks
    ui/                         # presentational, a11y-first components (Button, Modal, Input)
      Button/
      Modal/
      Input/
      index.ts
    hooks/                      # domain-agnostic hooks
      useDebouncedValue.ts
      usePrevious.ts
      useDisclosure.ts          # open/close with a11y patterns
      index.ts
    lib/                        # cross-cutting libs (api client, formatting)
      api/
      format/
    styles/                     # tokens, themes, CSS utilities
  entities/                     # optional: cross-feature domain models (Product, User)
```

# Components: design for reuse

* **Stable, minimal props.** Prefer primitive props + callbacks; avoid passing entire objects unless necessary.
* **Controlled/uncontrolled options.** e.g., `<Toggle on onChange/>` *and* internal state via `defaultOn`.
* **Polymorphic `as` pattern** (for UI primitives):
  `type ButtonProps<C extends ElementType = "button"> = { as?: C } & ComponentPropsWithoutRef<C> & { variant?: "primary" | "ghost" }`
* **A11y baked in.** Roles, `aria-*`, focus management; make the *accessible* thing the default.
* **Styling strategy.** Pick one (CSS Modules, Tailwind, or CSS-in-JS) and keep tokens in `shared/styles`.

# Hooks: design for reuse

* **Split data vs view concerns.**

  * Data hooks: `useUsers({ page, q })` → returns `{ data, loading, error }`.
  * UI state hooks: `useDisclosure()` → `{ isOpen, open, close, toggle }`.
* **Param-in, effect-out.** Don’t import singletons inside reusable hooks; accept dependencies as args (API client, config) for testability.
* **Return discriminated unions** for async state or provide `status` + typed `data`.
* **No hidden side effects.** If a hook causes network calls, name it accordingly (`useUsersQuery`), and document when it fires.

# Public API & boundaries

* Each folder’s `index.ts` is the **only** export consumers should import from.
* Use **barrel files** for ergonomics but keep the surface small.
* Enforce layering with ESLint rules or dependency-cruiser:

  * `app` → `features|shared|entities`
  * `features` ↔ `entities|shared`
  * `shared` → (nothing above)
* Add TS path aliases (`@app`, `@features/user`, `@shared/ui`) to keep import intent obvious.

# Promotion checklist (when moving to `shared/`)

* Used by ≥2 features.
* Props are stable and generic (no domain terms).
* A11y and tests exist.
* Storybook story documents variants.
* Tree-shakeable (no side-effecty imports; `package.json` has `"sideEffects": false` if you publish).

# Tooling & quality gates

* **Storybook** for visual contracts; include accessibility addon.
* **Jest/RTL** for components; **MSW** for hooks hitting network.
* **eslint-plugin-import** and **dependency-cruiser** to prevent illicit cross-feature imports.
* **Changesets/pnpm workspaces** if you split `shared` into a local package for versioned reuse.

# Example: a reusable hook + component

```ts
// shared/hooks/useDisclosure.ts
export function useDisclosure(initial = false) {
  const [isOpen, set] = useState(initial);
  const open = useCallback(() => set(true), []);
  const close = useCallback(() => set(false), []);
  const toggle = useCallback(() => set(v => !v), []);
  return { isOpen, open, close, toggle };
}
```

```tsx
// shared/ui/Modal/Modal.tsx
export function Modal({ open, onClose, children }: {
  open: boolean; onClose: () => void; children: React.ReactNode;
}) {
  // trap focus, Escape closes, aria-modal, role="dialog"
  if (!open) return null;
  return (
    <div role="dialog" aria-modal="true" aria-label="Dialog">
      <button onClick={onClose} aria-label="Close">×</button>
      {children}
    </div>
  );
}
```

```tsx
// features/user/components/UserSettings/UserSettings.tsx
export function UserSettings() {
  const { isOpen, open, close } = useDisclosure();
  return (
    <>
      <Button onClick={open}>Settings</Button>
      <Modal open={isOpen} onClose={close}>
        {/* settings form */}
      </Modal>
    </>
  );
}
```

# What to say in the interview (concise)

> “I colocate by feature for velocity and clear ownership. When something proves reusable, I promote it into `shared/ui` or `shared/hooks` with a small public API, a Storybook story, and tests. I enforce boundaries via ESLint/import rules and barrel files so features don’t secretly depend on each other. Hooks are split into data and UI state, accept deps as params, and return typed results. This keeps reuse intentional, testable, and easy to evolve.”

If you want, we can do the next architecture one—**“How do you approach styling (CSS Modules, Styled Components, Tailwind, tokens, theming)?”**—and I’ll give you a sharp comparison script you can use live.
