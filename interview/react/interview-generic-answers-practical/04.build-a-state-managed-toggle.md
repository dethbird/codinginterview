# 4. Write a **toggle component** that remembers its state across re-renders.

## a

I would start with `useSate()` for the toggle state.
```javascript
const [toggle, setToggle] = useState(false);
```

The the component would render that toggle state

```jsx
const Toggle = () => {
    return (
        <>
            <input type="button" value={toggle ? "on" : "off" } onClick={() => setToggle(prev => !prev )} >
        </>
    );
}
```

Something like that.

## A

Youâ€™re absolutely on the right track â€” thatâ€™s the minimal correct React pattern for a toggle. Youâ€™ve got:

* a **controlled state** (`useState`)
* a **UI reflecting that state**
* an **event handler** flipping it

Thatâ€™s 90% of what interviewers look for. Letâ€™s refine it slightly and then talk about what *â€œremembers across re-rendersâ€* and *â€œpersists across reloadsâ€* could mean â€” because theyâ€™re testing how you think about **state lifetime**.

---

### ğŸ’¡ Polished version (interview-ready)

```tsx
import { useState, useEffect } from "react";

export function Toggle() {
  const [on, setOn] = useState(false);

  return (
    <button
      type="button"
      aria-pressed={on}
      onClick={() => setOn((prev) => !prev)}
    >
      {on ? "ON" : "OFF"}
    </button>
  );
}
```

**Whatâ€™s better here**

* Uses `<button>` instead of `<input type="button">` for semantics and keyboard accessibility.
* Adds `aria-pressed={on}` â€” screen readers will announce it as a toggleable control.
* Keeps `onClick` logic small and declarative.

---

### ğŸ§  â€œRemembers across re-rendersâ€ â€” two possible interpretations

1. **Across renders of the same component instance (normal React)**
   â†’ âœ… `useState` already does this. Each re-render preserves `on` until unmounted.

2. **Across component unmounts or page reloads**
   â†’ you need **persistence** â€” either in `localStorage`, cookies, or URL params.
   Interviewers love when you volunteer this because it shows you think about *user continuity*.

Example:

```tsx
function PersistentToggle() {
  const [on, setOn] = useState(() => {
    // lazy initializer: read from localStorage once
    return localStorage.getItem("toggle") === "true";
  });

  useEffect(() => {
    localStorage.setItem("toggle", String(on));
  }, [on]);

  return (
    <button
      type="button"
      aria-pressed={on}
      onClick={() => setOn((p) => !p)}
    >
      {on ? "ON" : "OFF"}
    </button>
  );
}
```

Now the toggle survives page reloads.

---

### ğŸ—£ï¸ Interview phrasing

> â€œIâ€™d use `useState` for the toggle value and render it through a button with an `onClick` that flips the state. Since React preserves hook state across re-renders, the toggle naturally remembers its value while mounted.
>
> If the requirement means persistence across sessions, Iâ€™d initialize state from localStorage and write back on change. Thatâ€™s a one-liner with a lazy initializer in `useState`. For accessibility, Iâ€™d also use `aria-pressed`.â€

---

That last bit about accessibility and persistence turns a 3-line snippet into a â€œthis person thinks in productionâ€ answer.

Would you like to move on to the next practical one â€” â€œCreate a parent and child component where the parent can trigger a child action via refs or callbacksâ€?
