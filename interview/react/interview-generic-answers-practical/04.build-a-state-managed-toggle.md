# 4. Write a **toggle component** that remembers its state across re-renders.

## a

I would start with `useSate()` for the toggle state.
```javascript
const [toggle, setToggle] = useState(false);
```

The the component would render that toggle state

```jsx
const Toggle = () => {
    return (
        <>
            <input type="button" value={toggle ? "on" : "off" } onClick={() => setToggle(prev => !prev )} >
        </>
    );
}
```

Something like that.

## A

You’re absolutely on the right track — that’s the minimal correct React pattern for a toggle. You’ve got:

* a **controlled state** (`useState`)
* a **UI reflecting that state**
* an **event handler** flipping it

That’s 90% of what interviewers look for. Let’s refine it slightly and then talk about what *“remembers across re-renders”* and *“persists across reloads”* could mean — because they’re testing how you think about **state lifetime**.

---

### 💡 Polished version (interview-ready)

```tsx
import { useState, useEffect } from "react";

export function Toggle() {
  const [on, setOn] = useState(false);

  return (
    <button
      type="button"
      aria-pressed={on}
      onClick={() => setOn((prev) => !prev)}
    >
      {on ? "ON" : "OFF"}
    </button>
  );
}
```

**What’s better here**

* Uses `<button>` instead of `<input type="button">` for semantics and keyboard accessibility.
* Adds `aria-pressed={on}` — screen readers will announce it as a toggleable control.
* Keeps `onClick` logic small and declarative.

---

### 🧠 “Remembers across re-renders” — two possible interpretations

1. **Across renders of the same component instance (normal React)**
   → ✅ `useState` already does this. Each re-render preserves `on` until unmounted.

2. **Across component unmounts or page reloads**
   → you need **persistence** — either in `localStorage`, cookies, or URL params.
   Interviewers love when you volunteer this because it shows you think about *user continuity*.

Example:

```tsx
function PersistentToggle() {
  const [on, setOn] = useState(() => {
    // lazy initializer: read from localStorage once
    return localStorage.getItem("toggle") === "true";
  });

  useEffect(() => {
    localStorage.setItem("toggle", String(on));
  }, [on]);

  return (
    <button
      type="button"
      aria-pressed={on}
      onClick={() => setOn((p) => !p)}
    >
      {on ? "ON" : "OFF"}
    </button>
  );
}
```

Now the toggle survives page reloads.

---

### 🗣️ Interview phrasing

> “I’d use `useState` for the toggle value and render it through a button with an `onClick` that flips the state. Since React preserves hook state across re-renders, the toggle naturally remembers its value while mounted.
>
> If the requirement means persistence across sessions, I’d initialize state from localStorage and write back on change. That’s a one-liner with a lazy initializer in `useState`. For accessibility, I’d also use `aria-pressed`.”

---

That last bit about accessibility and persistence turns a 3-line snippet into a “this person thinks in production” answer.

Would you like to move on to the next practical one — “Create a parent and child component where the parent can trigger a child action via refs or callbacks”?
