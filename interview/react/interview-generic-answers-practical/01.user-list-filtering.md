# 1. Given a list of items, how would you render them and handle user input filtering?

## a

    I would render the list so that each item had a truly unique key, something like a UUID and render it paginated. When a user begins typing a search term in a controlled input, it would callback to a function that filters the array if list items potentially across multiple item properties like name, description, or other text-searchable fields. If this was a giant list, it might make sense to move toward something like elasticsearch with different facets. 

## A

You’re on the right track. A few upgrades will make this interview-ready:

* Don’t generate UUIDs during render—use a **stable id from the data** (e.g., `item.id`). Generating per render breaks reconciliation.
* Use a **controlled input** + **debounce** (or `useDeferredValue`) so you don’t filter on every keystroke.
* Keep filtering **pure and memoized** (`useMemo`) and paginate from the filtered array.
* For very large lists, add **virtualization** (`react-window`) and move filtering **off the main thread** (web worker) or **server-side** (search API). Elasticsearch is fine, but you can also start with simple server queries or Fuse.js for fuzzy matches.

Here’s a compact React + TypeScript pattern that hits the marks:

```tsx
import { useMemo, useState, useDeferredValue, useCallback } from "react";

type Item = { id: string; name: string; description?: string; tags?: string[] };

function useDebouncedValue<T>(value: T, delay = 300) {
  const [v, setV] = useState(value);
  // simple debounce without effects library
  useMemo(() => {
    const t = setTimeout(() => setV(value), delay);
    return () => clearTimeout(t);
  }, [value, delay]);
  return v;
}

export function FilterableList({ items }: { items: Item[] }) {
  const [query, setQuery] = useState("");
  const [page, setPage] = useState(1);
  const pageSize = 20;

  // Option A: debounce typing to reduce recomputes
  const debouncedQuery = useDebouncedValue(query, 250);
  // Option B (React 18): de-prioritize updates
  const deferredQuery = useDeferredValue(debouncedQuery);

  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      setPage(1);
      setQuery(e.target.value);
    },
    []
  );

  const filtered = useMemo(() => {
    const q = deferredQuery.trim().toLowerCase();
    if (!q) return items;
    return items.filter((it) => {
      const haystack = [
        it.name,
        it.description ?? "",
        ...(it.tags ?? []),
      ].join(" ").toLowerCase();
      return haystack.includes(q);
    });
  }, [items, deferredQuery]);

  const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
  const pageItems = useMemo(() => {
    const start = (page - 1) * pageSize;
    return filtered.slice(start, start + pageSize);
  }, [filtered, page, pageSize]);

  return (
    <section>
      <label htmlFor="search">Search</label>
      <input
        id="search"
        value={query}
        onChange={handleChange}
        placeholder="Type to filter..."
      />

      <p aria-live="polite">
        {filtered.length} result{filtered.length !== 1 ? "s" : ""}
      </p>

      <ul>
        {pageItems.map((item) => (
          <li key={item.id /* stable key from data */}>
            <strong>{item.name}</strong>
            {item.description ? <div>{item.description}</div> : null}
          </li>
        ))}
      </ul>

      <nav aria-label="Pagination">
        <button disabled={page <= 1} onClick={() => setPage((p) => p - 1)}>
          Prev
        </button>
        <span>
          Page {page} / {totalPages}
        </span>
        <button
          disabled={page >= totalPages}
          onClick={() => setPage((p) => p + 1)}
        >
          Next
        </button>
      </nav>
    </section>
  );
}
```

What you improved vs your draft:

* **Keys:** use `item.id` (stable), not freshly minted UUIDs.
* **Filtering:** memoized and case-insensitive; resets to page 1 on new query.
* **Perf:** debounce + `useDeferredValue`; paginate post-filter; no work on every keystroke.
* **A11y:** labeled input, polite result count, disabled pagination buttons.

Scaling notes (say these out loud if they push):

* **Big-O:** naive filter is `O(n)` per query. For ~10k items it’s fine with debounce; beyond that, consider **indexing** (Fuse.js for fuzzy; MiniSearch) or **server-side filtering** with pagination.
* **Very large lists:** add **virtualization** to keep DOM nodes low (`react-window`); this is often a bigger win than micro-optimizing the filter.
* **Threading:** move heavy filtering into a **Web Worker** to keep typing smooth.
* **Server truth:** if the list is authoritative on the server, prefer **API queries** with `q` and `page` params over client-side filtering.

Bonus: tiny RTL test targets (interview candy)

* Debounce: type “spa” quickly, `waitFor` a single filter call or check count after 250ms.
* Pagination: click Next, assert items render and buttons enable/disable correctly.

If you want, we can do a “hard mode” variant next: add **highlighting** of the matched substring and **list virtualization**—that’s a very Series-C thing to ask.
