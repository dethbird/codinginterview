# 5. Create a parent and child component where the parent can trigger a child action via **refs or callbacks**.

## a

    With callbacks I would create the callback function and pass it down to the child along with props. The child component would use the callback when some event was triggered by the user. This would call the callback function, recalculate props and send them back down to the child. With refs, it is similar but the parent would call the ref which is actually inside the child component. My refs answer was not great if you can help me.

## A

You’ve got the callback story right. For the **ref** version, the idiomatic React way is to expose an **imperative handle** from the child so the parent can call specific methods (focus, open, scrollTo, reset, etc.). Here’s the clean pattern, plus when to choose each.

### 1) Callback pattern (data up, events up)

Use when the **parent owns the state** and the child just *notifies*.

```tsx
// Child.tsx
type ChildProps = { onSelect: (id: string) => void };
export function Child({ onSelect }: ChildProps) {
  return <button onClick={() => onSelect("42")}>Select</button>;
}

// Parent.tsx
import { useCallback, useState } from "react";
export function Parent() {
  const [selectedId, setSelectedId] = useState<string | null>(null);
  const handleSelect = useCallback((id: string) => setSelectedId(id), []);
  return (
    <>
      <Child onSelect={handleSelect} />
      <p>Selected: {selectedId}</p>
    </>
  );
}
```

**Notes**

* Parent owns the data → easy to test, predictable renders.
* If the child is memoized (`React.memo`), keep callbacks stable with `useCallback`.

---

### 2) Ref pattern (imperative handle)

Use when the **parent must trigger an action inside the child** (focus an input, open a popover, reset internal form state) that isn’t naturally expressed as props.

```tsx
// FancyInput.tsx
import { forwardRef, useImperativeHandle, useRef, useState } from "react";

export type FancyInputRef = {
  focus: () => void;
  clear: () => void;
  setValue: (v: string) => void;
};

type Props = { initial?: string };

export const FancyInput = forwardRef<FancyInputRef, Props>(function FancyInput(
  { initial = "" },
  ref
) {
  const [value, setValue] = useState(initial);
  const inputRef = useRef<HTMLInputElement>(null);

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current?.focus(),
    clear: () => setValue(""),
    setValue: (v) => setValue(v),
  }), []); // exposed API stable

  return (
    <input
      ref={inputRef}
      value={value}
      onChange={(e) => setValue(e.target.value)}
      placeholder="Type here…"
    />
  );
});
```

```tsx
// Parent.tsx
import { useRef } from "react";
import { FancyInput, type FancyInputRef } from "./FancyInput";

export function Parent() {
  const inputRef = useRef<FancyInputRef>(null);

  return (
    <>
      <FancyInput ref={inputRef} initial="hello" />
      <div className="controls">
        <button onClick={() => inputRef.current?.focus()}>Focus</button>
        <button onClick={() => inputRef.current?.clear()}>Clear</button>
        <button onClick={() => inputRef.current?.setValue("world")}>Set “world”</button>
      </div>
    </>
  );
}
```

**What’s happening**

* `forwardRef` lets the parent attach a ref to a function component.
* `useImperativeHandle` defines the **public methods** the parent can call.
* The child still controls its own internal state; the parent just *requests actions*.

---

### When to use which

* **Callbacks/controlled props**: default choice for data and UI state; flows are declarative; easy to reason about.
* **Refs / imperative handle**: targeted, UI-centric actions (focus, open/close, scroll). Keep the exposed API **small and intentional**.

---

### Pitfalls to avoid

* Don’t generate new callbacks every render if the child is memoized (wrap in `useCallback`).
* Don’t overuse refs for *data flow*. If the parent needs to *own* the value, lift state and use props instead.
* Don’t expose child internals wholesale; expose a tiny, stable API (focus/clear/open).

If you want to push this further, the “grown-up” version is a **controlled + imperative** hybrid: parent owns a boolean `open` prop, while the child also exposes `open()`/`close()` for convenience. That pattern plays nicely with both declarative state and ad-hoc user actions.
