#2. Implement a custom **hook** like `useFetch` or `usePrevious`.

## a

    I have to admit I don't even know how to go about this.

## A

No worries—that’s super common. Let’s build two hooks you can write from muscle memory in an interview: a tiny `usePrevious` and a production-flavored `useFetch` with abort + retries. I’ll keep them TypeScript and point out what to say while you code.

---

## 1) `usePrevious<T>` (the “easy win” hook)

**What it does:** returns the **previous** value of something across renders.

```tsx
import { useEffect, useRef } from "react";

export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T>();
  useEffect(() => {
    ref.current = value; // after render, store the latest for next time
  }, [value]);
  return ref.current;
}
```

**Talking points while you type**

* `useRef` holds a mutable box that doesn’t trigger re-renders.
* We update it **after** render in `useEffect`, so the returned value is the last render’s value.
* Return type is `T | undefined` because there’s no “previous” on the first render.

**Quick usage**

```tsx
const [count, setCount] = useState(0);
const prev = usePrevious(count); // undefined → 0 → 1 ...
```

**Tiny test ideas**

* Initial render returns `undefined`.
* After `setState`, `usePrevious` returns the prior value.

---

## 2) `useFetch<T>` (abort-safe, retryable, dependency-aware)

**What it does:** fetches data when `url`/`options` change, handles loading/error, cancels stale requests, and supports an optional `select` to map the response.

```tsx
import { useEffect, useMemo, useReducer, useRef } from "react";

type FetchState<T> =
  | { status: "idle"; data: null; error: null }
  | { status: "loading"; data: null; error: null }
  | { status: "success"; data: T; error: null }
  | { status: "error"; data: null; error: Error };

type FetchAction<T> =
  | { type: "start" }
  | { type: "success"; payload: T }
  | { type: "error"; payload: Error };

function fetchReducer<T>(state: FetchState<T>, action: FetchAction<T>): FetchState<T> {
  switch (action.type) {
    case "start": return { status: "loading", data: null, error: null };
    case "success": return { status: "success", data: action.payload, error: null };
    case "error": return { status: "error", data: null, error: action.payload };
    default: return state;
  }
}

type UseFetchOptions<TOut> = {
  init?: RequestInit;
  // map the raw JSON into a typed shape (nice for shaping DTOs)
  select?: (raw: any) => TOut;
  // naive retry count for transient failures
  retries?: number;
  // opt-out of auto run
  enabled?: boolean;
};

export function useFetch<TOut = unknown>(
  url: string | null,
  { init, select, retries = 0, enabled = true }: UseFetchOptions<TOut> = {}
) {
  const [state, dispatch] = useReducer(fetchReducer<TOut>, {
    status: "idle",
    data: null,
    error: null,
  });

  // Stabilize dependencies to avoid accidental re-fetch explosions
  const memoInit = useMemo(() => init, [init]); // usually stable already
  const memoSelect = useMemo(() => select ?? ((x: any) => x as TOut), [select]);
  const abortRef = useRef<AbortController | null>(null);

  useEffect(() => {
    if (!enabled || !url) return;

    let cancelled = false;
    let attempts = 0;

    const run = async () => {
      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;

      dispatch({ type: "start" });
      while (true) {
        try {
          const res = await fetch(url, { signal: controller.signal, ...memoInit });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const raw = await res.json();
          if (cancelled) return;
          dispatch({ type: "success", payload: memoSelect(raw) });
          return;
        } catch (err: any) {
          if (controller.signal.aborted) return; // stale request aborted
          if (attempts < retries) {
            attempts++;
            continue; // retry
          }
          if (cancelled) return;
          dispatch({ type: "error", payload: err instanceof Error ? err : new Error(String(err)) });
          return;
        }
      }
    };

    run();
    return () => {
      cancelled = true;
      abortRef.current?.abort();
    };
  }, [url, memoInit, memoSelect, enabled, retries]);

  // expose a manual retry that replays the effect by nudging a refetch key
  const refetch = () => {
    // simplest: toggle enabled off/on by a tiny trick—force effect deps:
    // realistically you'd keep a "bump" state and include it in deps.
    // For the interview, returning an explicit refetch that calls run() is fine to explain,
    // but here we’ll suggest the bump approach:
    console.warn("Consider implementing a refetch bump state in production.");
  };

  return {
    ...state, // {status, data, error}
    loading: state.status === "loading",
    refetch,
  };
}
```

**Talking points while you code**

* **Reducer + discriminated union** keeps states “impossible to represent incorrectly.”
* **AbortController** cancels stale in-flight fetches when inputs change or on unmount.
* **Retries** handle transient failures (you can mention exponential backoff as a next step).
* **`select` mapper** lets consumers shape the JSON into a typed model—this wins interviews.
* **Dependencies**: re-fetch on `url/init/select/enabled/retries` change.

**Quick usage**

```tsx
type User = { id: string; name: string };

function Users() {
  const { data, loading, error } = useFetch<User[]>(
    "/api/users",
    { select: (raw) => raw.users as User[], retries: 1 }
  );

  if (loading) return <p>Loading…</p>;
  if (error) return <p role="alert">Failed: {error.message}</p>;
  if (!data?.length) return <p>No users</p>;

  return <ul>{data.map(u => <li key={u.id}>{u.name}</li>)}</ul>;
}
```

**Test angles (React Testing Library + MSW)**

* Happy path: mock `/api/users` → assert “Loading…” then list renders.
* Abort: render with URL A, immediately rerender with URL B → ensure only B’s result appears.
* Retry: fail once with 500, succeed second time → ends “success”.
* Error path: 404 → `role="alert"` message shows.

---

## Tiny “how to think out loud” script (interview gold)

> “For `usePrevious`, I store the last value in a ref and update it in an effect so the hook returns the previous render’s value.
> For `useFetch`, I model state with a discriminated union, use `AbortController` to cancel stale requests, and expose `loading/error/data`. I re-run on dependency changes and allow a `select` mapper so consumers get strongly typed, shaped data. In production I’d add an optional `staleTime`/cache or adopt TanStack Query for full server-state management.”

If you want, we can add a **refetch bump** and a **simple in-memory cache** for `useFetch` next, or do a different practical like **debounced search with highlighting**.
