# 2. “Design a feature flag system in the client. Where do types live? How do you test fallbacks?”

## a

I'm not sure where [flags] enabled for the user would come from. If it is 3rd party, then I'm assuming the auth logic before the request to the app would populate a JWT with that information. Once we have that, it can be placed in a userContext to be used throughout the app. I would prefer splits happen at a component level granularity. That way, a FeatureSplit wrapper could be placed where the split needs to happen. It would show one component if the flag was on but fallback to the existing one. FeatureSplit could also handle measurements needed to properly track the split. I don't know what "where to types live" means in this context.

## A

Love this one. You’re already close to a solid design—let’s tighten it up.

## What you got right

* **Source of truth**: flags likely come from your auth/feature service (JWT claims, remote config, LaunchDarkly/GrowthBook, your own API). ✔️
* **Consumption model**: expose flags through a **context + hook** so any component can gate behavior. ✔️
* **Granularity**: keep splits at **component boundaries** with a `FeatureGate` wrapper and log exposures. ✔️

## What was missing

* **Types**: define a **single flag registry** that encodes keys and value types (boolean / string variant / number), and generate types from it.
* **Bootstrapping & refresh**: how flags load on first paint (SSR/initial HTML, JWT bootstrap, or prefetch) and how they refresh (polling, on focus, user-change).
* **Multi-variant & targeting**: not just on/off—support string/number variants and per-user rules.
* **Testing fallbacks**: deterministic ways to force flags in unit/integration/E2E; test “on”, “off”, and “unknown” with defaults; verify **exposure events** fire once.
* **Performance & safety**: avoid re-render storms; remember flags ≠ auth—never trust the client for security.

---

## Interview-ready design (TypeScript + React)

### 1) Define flags once (types live **with the registry**)

Create a single registry that is the contract for client + (optionally) server.

```ts
// flags/registry.ts
export const flagRegistry = {
  newCheckout: { type: 'boolean' as const, default: false, description: 'Enable new checkout flow' },
  searchBackend: { type: 'string' as const, default: 'v1', variants: ['v1', 'v2'] as const },
  resultsPageSize: { type: 'number' as const, default: 20, min: 5, max: 100 },
};
export type FlagKey = keyof typeof flagRegistry;
export type FlagValue<K extends FlagKey> =
  typeof flagRegistry[K] extends { type: 'boolean' } ? boolean :
  typeof flagRegistry[K] extends { type: 'string', variants: readonly (infer V)[] } ? V :
  number;
```

* **Answer to “where do types live?”** → **Right next to the registry** that defines your flags.
* In a monorepo, export this from a `@acme/flags` package shared by app(s), tests, and even the node backend for SSR.

Optional: enforce runtime with Zod/Valibot and generate TS types from JSON schema if flags are delivered from a config service.

### 2) Provider + hook (bootstrapped, memoized, exposure logging)

```tsx
// flags/FlagsProvider.tsx
import React from 'react';
import { flagRegistry, type FlagKey, type FlagValue } from './registry';

type FlagBag = { [K in FlagKey]: FlagValue<K> };
type FlagsContextType = {
  flags: FlagBag;
  // access helper
  get<K extends FlagKey>(key: K): FlagValue<K>;
  // override for tests/dev-tools
  set<K extends FlagKey>(key: K, value: FlagValue<K>): void;
};

const FlagsContext = React.createContext<FlagsContextType | null>(null);

// Bootstrapping: from SSR, JWT claims, or a prefetch call
export function FlagsProvider({
  initialFlags,
  children,
}: { initialFlags?: Partial<FlagBag>, children: React.ReactNode }) {
  const [flags, setFlags] = React.useState<FlagBag>(() => {
    // fill missing with defaults from registry
    const base = {} as FlagBag;
    (Object.keys(flagRegistry) as FlagKey[]).forEach(k => {
      // @ts-expect-error simplify
      base[k] = (initialFlags?.[k] ?? flagRegistry[k].default) as any;
    });
    return base;
  });

  // avoid re-creating context value on unrelated renders
  const ctx = React.useMemo<FlagsContextType>(() => ({
    flags,
    get: (k) => flags[k],
    set: (k, v) => setFlags(prev => ({ ...prev, [k]: v })),
  }), [flags]);

  return <FlagsContext.Provider value={ctx}>{children}</FlagsContext.Provider>;
}

export function useFlag<K extends FlagKey>(key: K): FlagValue<K> {
  const ctx = React.useContext(FlagsContext);
  if (!ctx) throw new Error('useFlag must be used within FlagsProvider');
  return ctx.get(key);
}
```

* **Bootstrapping**: pass `initialFlags` from SSR, or decode from the user’s JWT at login, or fetch `/feature-flags` at app start and hydrate here.
* **Refresh**: re-fetch flags on focus or user switch, then `set` into provider.
* **Perf**: the provider value is memoized; consumers select by key to limit updates.

### 3) Component-level gating (boolean and multi-variant)

```tsx
// flags/FeatureGate.tsx
import { useFlag } from './FlagsProvider';

export function FeatureGate<K extends FlagKey>({
  flag,
  when,
  children,
  fallback = null,
  onExpose,        // optional exposure logging
}: {
  flag: K;
  when?: (value: FlagValue<K>) => boolean; // default: truthy for boolean
  children: React.ReactNode;
  fallback?: React.ReactNode;
  onExpose?: (key: K, value: FlagValue<K>) => void;
}) {
  const value = useFlag(flag);
  const enabled = when ? when(value) : Boolean(value);

  // fire exposure at first render of either branch
  React.useEffect(() => { onExpose?.(flag, value); }, [flag, value, onExpose]);

  return <>{enabled ? children : fallback}</>;
}

// Usage samples
// boolean split
<FeatureGate flag="newCheckout" fallback={<LegacyCheckout />}>
  <NewCheckout />
</FeatureGate>

// variant split
<FeatureGate flag="searchBackend" when={(v) => v === 'v2'} fallback={<SearchV1 />}>
  <SearchV2 />
</FeatureGate>
```

### 4) Data loading + flags (don’t block UX)

* Keep flags **small and fast**. Load at app boot; don’t tie route transitions to flag fetch unless absolutely necessary.
* For experiment flags tied to API behavior, keep **server as source of truth**—the backend should also evaluate flags to avoid client-side spoofing.

### 5) Security & correctness

* **Never** use client flags for authorization. Server must enforce.
* If a flag swaps endpoints or payloads, the **server** should gate behavior consistently with the client.

---

## Testing fallbacks (unit, integration, E2E)

**Unit tests** (Jest + RTL):

```tsx
import { render, screen } from '@testing-library/react';
import { FlagsProvider } from '../flags/FlagsProvider';
import { FeatureGate } from '../flags/FeatureGate';

test('renders fallback when flag off', () => {
  render(
    <FlagsProvider initialFlags={{ newCheckout: false }}>
      <FeatureGate flag="newCheckout" fallback={<span>legacy</span>}>
        <span>new</span>
      </FeatureGate>
    </FlagsProvider>
  );
  expect(screen.getByText('legacy')).toBeInTheDocument();
});

test('renders new when flag on', () => {
  render(
    <FlagsProvider initialFlags={{ newCheckout: true }}>
      <FeatureGate flag="newCheckout" fallback={<span>legacy</span>}>
        <span>new</span>
      </FeatureGate>
    </FlagsProvider>
  );
  expect(screen.getByText('new')).toBeInTheDocument();
});
```

**Exposure logging**: assert your `onExpose` spy fires **once** per mount, not every re-render.

**Integration**:

* Provide a **test harness** that sets `initialFlags` per test.
* For data-backed flags, mock your `/feature-flags` API with **MSW**.

**E2E** (Playwright/Cypress):

* Add a **query param** or **localStorage** override for flags in test builds (`?flags=newCheckout:true,searchBackend:v2`) that the provider reads and merges over server values.
* Test both branches of critical flows.

---

## Bonus: experiments vs. release toggles

* **Release toggles** (boolean): enable incomplete code paths safely.
* **Experiment toggles** (multi-variant): A/B/n with exposure and assignment. Keep assignments **stable per user** (e.g., hash(userId, flagKey) % 100).
* Log exposures at **first evaluation** per view to feed your analytics.

---

## Performance guardrails

* Memoize provider value.
* Prefer **selector-style consumption** (single-flag reads) to minimize re-renders.
* Don’t prefetch giant rule sets—download only the flags needed for the current product surface.
* Respect Data Saver: skip experiment preloads if `navigator.connection.saveData` is true.

---

## Interview “say it out loud” version

**“I keep a single type-safe flag registry that defines every flag’s key and value type—boolean, string variant, or number—and export types from it. At app start I bootstrap flags from SSR, a JWT claim, or a `/feature-flags` endpoint and provide them through a memoized FlagsProvider with a `useFlag(key)` hook. Splits happen at component boundaries via a small `FeatureGate` that renders the new path or a fallback and logs an exposure the first time it’s evaluated.**

**For prop drilling, I avoid it entirely by colocating the provider near the feature, and consumers read individual keys so updates don’t cascade. Experiments use multi-variant flags with stable assignment and first-exposure logging; release toggles are simple booleans. Testing fallbacks is straightforward: in unit and integration tests I seed `initialFlags` to force on/off and assert both branches, and in E2E I allow a query-param or localStorage override. Flags never replace server-side authorization—the backend also evaluates critical flags so behavior stays consistent and secure.”**

Want me to wrap this into a tiny `@acme/flags` package skeleton (registry, provider, gate, tests) you can paste into a repo?

## Flags repo

Done. I bundled a tiny, type-safe feature-flag package with a provider, hook, gate component, tests, and docs.

[Download **acme-flags.zip**](sandbox:/mnt/data/acme-flags.zip)

What’s inside:

* `src/registry.ts` — single source of truth for flags + generated types
* `src/FlagsProvider.tsx` — memoized provider, `useFlag`/`useFlags`, URL override parser for tests/E2E
* `src/FeatureGate.tsx` — component-level gating with optional exposure logging
* `src/__tests__/FeatureGate.test.tsx` — RTL + Vitest examples
* `README.md`, `package.json`, `tsconfig.json`, `vitest.config.ts`

Usage sketch:

* Bootstrap flags from SSR/JWT/`/feature-flags` and pass into `<FlagsProvider initialFlags={...}>`
* Wrap new vs legacy UI with `<FeatureGate flag="newCheckout" fallback={<Legacy/>}><New/></FeatureGate>`
* Read values directly: `const variant = useFlag('searchBackend')`

If you want a variant-assignment helper (hash userId → bucket → variant) or an analytics exposure adapter, I can add those next.
