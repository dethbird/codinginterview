# 4. How does **React.memo**

## a

    React.memo "caches" a component unless there is a shallow diff change in it's props

## A

That‚Äôs a solid one-liner summary ‚Äî you‚Äôve captured the *mechanism* (shallow comparison of props) and the *intent* (prevent unnecessary re-renders).

Let‚Äôs deepen it a bit so you can sound confident, precise, and senior-level when describing it in an interview.

---

### üí° Interview-ready explanation

> `React.memo` is a higher-order component that wraps a **pure functional component**. It memoizes the rendered output ‚Äî React will skip re-rendering that component if its **props haven‚Äôt changed**, determined via a **shallow comparison** of the previous and next props.
>
> It‚Äôs similar to `PureComponent` for class components. You can also pass a custom comparison function as a second argument if you need more control:
>
> ```tsx
> export default React.memo(MyComponent, (prev, next) => prev.id === next.id);
> ```
>
> This helps optimize expensive components that render frequently with the same props.

---

### ‚ö†Ô∏è Pitfalls (where most candidates stumble)

1. **Shallow comparison only:**
   It only checks top-level prop values by reference.
   If you pass new object or function literals each render, React.memo becomes useless:

   ```tsx
   <Child style={{ color: 'red' }} /> // new object every render ‚Üí always re-renders
   ```

   That‚Äôs why people pair it with `useMemo` / `useCallback`.

2. **It doesn‚Äôt stop parent re-renders:**
   It only prevents *this component‚Äôs* re-render ‚Äî the parent still renders. It‚Äôs not magic performance dust.

3. **Overuse can hurt performance:**
   The comparison itself costs time; wrapping cheap components can make things *slower*.

4. **Context and hooks still trigger renders:**
   If a memoized component consumes a context that changes, it re-renders regardless of memoization.

5. **Subtle stale prop bugs:**
   If your equality function is wrong, your component might skip a necessary update.

---

### üß† A smooth interview phrasing

> ‚Äú`React.memo` wraps a functional component and memoizes its output based on a shallow prop comparison. It prevents re-rendering when props are identical, but it doesn‚Äôt freeze the component ‚Äî state and context changes still cause renders.
> The pitfalls are mainly around reference equality: if you create new objects or callbacks inline, `React.memo` won‚Äôt help. And if you overuse it, you can actually hurt performance due to the comparison overhead.‚Äù

---

That‚Äôs a professional, production-aware answer ‚Äî both technically accurate and concise.

Next logical question: **Explain `useEffect`‚Äôs dependency array and common mistakes.**
Want to take a swing at that one next?
