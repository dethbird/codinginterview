# 3. What triggers a **re-render** in React, and how can you avoid unnecessary renders?

## a

    re-renders are triggered by state changes. I don't know how to avoid unecessary re renders

## A

Excellent place to start — the “state changes cause re-renders” part is correct, but there’s more depth you can unlock to sound fluent in how React *actually* reasons about updates.

Let’s flesh it out and then I’ll show you how to elegantly talk about *avoiding* extra renders without memorizing buzzwords.

---

### 🔍 Expanded understanding

Re-renders in React are triggered whenever **React detects a change in data that affects what should be rendered**. That can come from:

1. **State updates** via `setState` or `useState`.
2. **Prop changes** — if a parent re-renders and passes new prop values (especially new object or function references).
3. **Context value changes** — any component consuming that context re-renders.
4. **Force updates** (`forceUpdate`, or external store triggers, though rare).

React then re-runs the render function of that component and its children (unless prevented by memoization).

---

### 💡 Avoiding unnecessary renders

There are several patterns to control or minimize re-renders when performance matters:

* **Component boundaries**: Split large components into smaller ones so that updates don’t cascade unnecessarily.
* **`React.memo`**: Wrap a component so it only re-renders when its props change by shallow comparison.
* **`useMemo` and `useCallback`**: Stabilize function and object references passed as props; otherwise, each render creates new references and triggers re-renders in children.

  ```tsx
  const handleClick = useCallback(() => setCount(c => c + 1), []);
  const config = useMemo(() => ({ theme }), [theme]);
  ```
* **Derived state**: Avoid storing data in state that can be derived from props — recompute instead of duplicating.
* **Context discipline**: Keep contexts small and specific; avoid one big context that forces everything to re-render when it updates.
* **Batching**: React 18 automatically batches multiple state updates in an event loop tick, reducing render counts.

---

### 🧠 Interview-ready phrasing

> A React component re-renders when its state changes, when its parent passes new props, or when it consumes context that changes.
> To avoid unnecessary re-renders, I stabilize values passed to children using `useMemo` and `useCallback`, split components logically so updates stay localized, and wrap pure components in `React.memo` when appropriate.
> The goal isn’t to prevent all re-renders, but to avoid *wasteful* ones — React’s reconciliation is fast when the tree is shallow and the data flow is predictable.

---

### Why this version works

It demonstrates:

* You know **what** causes renders.
* You understand **why React does it** (data flow).
* You can name **specific, concrete techniques**.
* You sound like someone who’s debugged render loops before.

---

If you want to practice, the next logical question builds right on this one:
**“How does React.memo work, and what are its pitfalls?”**
Would you like to take a stab at that one next?
