# 3. What triggers a **re-render** in React, and how can you avoid unnecessary renders?

## a

    re-renders are triggered by state changes. I don't know how to avoid unecessary re renders

## A

Excellent place to start â€” the â€œstate changes cause re-rendersâ€ part is correct, but thereâ€™s more depth you can unlock to sound fluent in how React *actually* reasons about updates.

Letâ€™s flesh it out and then Iâ€™ll show you how to elegantly talk about *avoiding* extra renders without memorizing buzzwords.

---

### ğŸ” Expanded understanding

Re-renders in React are triggered whenever **React detects a change in data that affects what should be rendered**. That can come from:

1. **State updates** via `setState` or `useState`.
2. **Prop changes** â€” if a parent re-renders and passes new prop values (especially new object or function references).
3. **Context value changes** â€” any component consuming that context re-renders.
4. **Force updates** (`forceUpdate`, or external store triggers, though rare).

React then re-runs the render function of that component and its children (unless prevented by memoization).

---

### ğŸ’¡ Avoiding unnecessary renders

There are several patterns to control or minimize re-renders when performance matters:

* **Component boundaries**: Split large components into smaller ones so that updates donâ€™t cascade unnecessarily.
* **`React.memo`**: Wrap a component so it only re-renders when its props change by shallow comparison.
* **`useMemo` and `useCallback`**: Stabilize function and object references passed as props; otherwise, each render creates new references and triggers re-renders in children.

  ```tsx
  const handleClick = useCallback(() => setCount(c => c + 1), []);
  const config = useMemo(() => ({ theme }), [theme]);
  ```
* **Derived state**: Avoid storing data in state that can be derived from props â€” recompute instead of duplicating.
* **Context discipline**: Keep contexts small and specific; avoid one big context that forces everything to re-render when it updates.
* **Batching**: React 18 automatically batches multiple state updates in an event loop tick, reducing render counts.

---

### ğŸ§  Interview-ready phrasing

> A React component re-renders when its state changes, when its parent passes new props, or when it consumes context that changes.
> To avoid unnecessary re-renders, I stabilize values passed to children using `useMemo` and `useCallback`, split components logically so updates stay localized, and wrap pure components in `React.memo` when appropriate.
> The goal isnâ€™t to prevent all re-renders, but to avoid *wasteful* ones â€” Reactâ€™s reconciliation is fast when the tree is shallow and the data flow is predictable.

---

### Why this version works

It demonstrates:

* You know **what** causes renders.
* You understand **why React does it** (data flow).
* You can name **specific, concrete techniques**.
* You sound like someone whoâ€™s debugged render loops before.

---

If you want to practice, the next logical question builds right on this one:
**â€œHow does React.memo work, and what are its pitfalls?â€**
Would you like to take a stab at that one next?
