# 6. How would you manage **global state**? When do you pick Context vs Redux vs Zustand?

## a
    I would manage global state with slices using reducers. Each feature component of the app would be responsible for it's slice of the state. useContext with contextProvider is another way to share parts of state with lower level components. I don't know what Zustand is

    ## A

    Thatâ€™s actually a very good and pragmatic start â€” youâ€™re already showing that you think in terms of **modular state slices** and **context boundaries**, which is how most teams keep React code maintainable. Letâ€™s polish that answer into one that sounds seasoned and strategic, and Iâ€™ll fill you in on Zustand along the way.

---

### ğŸ’¡ Interview-ready explanation

> In React, I manage state based on **scope**:
>
> * **Local state** with `useState` or `useReducer` for data that only affects one component.
> * **Shared or global state** with Context, Redux Toolkit, or a lightweight library like Zustand depending on how widely itâ€™s needed and how predictable updates must be.
>
> For complex apps, I structure state into **slices** â€” each feature owns its own reducer and actions. Redux Toolkit makes that easy and gives you time-travel debugging, middleware, and predictable updates.
>
> If the global state is small or mostly static (e.g. theme, user, or locale), Context + a Provider is simpler.
>
> For performance-sensitive or ergonomic cases, **Zustand** is a minimalist state library that uses native React hooks under the hood. It gives you a global store without boilerplate and re-renders only the components that actually use the changed data.

---

### ğŸ§  Quick breakdown of each option

**Context / Provider pattern**

* Great for small bits of state shared across the tree (theme, auth, config).
* Lightweight, built into React.
* Downside: every consumer re-renders when the context value changes unless you memoize or split contexts.

**Redux / Redux Toolkit**

* Best when you need predictable updates, immutability, middleware, and debugging tools.
* Excellent for large teams or when you need time-travel devtools and action logging.
* More boilerplate (though Toolkit reduces that dramatically).

**Zustand**

* Think of it as â€œglobal useState.â€
* You create a store hook:

  ```ts
  const useStore = create(set => ({
    count: 0,
    inc: () => set(state => ({ count: state.count + 1 })),
  }));
  ```

  Then you call `const count = useStore(s => s.count)` in any component.
* Tiny API, great performance, zero context re-render issues.

---

### ğŸ—£ï¸ Polished answer version

> â€œI manage global state based on how complex and shared it is. For lightweight cross-component state like theme or user data, Iâ€™ll use React Context with a provider. For more complex or cross-cutting data, I organize it into feature slices with reducers â€” Redux Toolkit makes that pattern easy and predictable.
>
> If I need global state without Reduxâ€™s ceremony, Iâ€™ll reach for Zustand â€” itâ€™s a small, hook-based library that provides a global store with minimal re-renders. The main goal is to keep ownership clear and avoid a single monolithic global store.â€

---

Thatâ€™s an answer that makes you sound like youâ€™ve seen scale and still value simplicity â€” exactly what most Series C interviewers want to hear.

Want to move to the next one in your list â€” maybe **â€œWhatâ€™s the difference between server-side rendering, client-side rendering, and hydration?â€**?
