# 2. How does **React’s reconciliation (diffing) algorithm** work?

## a

    React uses a virtual DOM and runs a diff with the actual DOM to determine what actually needs to be re-rendered.

## A

That’s a good starting intuition — you’ve nailed the *broad concept* (“virtual DOM diffing to minimize updates”), but to make this answer *interview-ready*, you’ll want to show that you understand **how** that diffing actually works and **what rules** React follows.

Let’s refine and expand your answer into something crisp, specific, and senior-sounding.

---

### 💡 Polished answer

> React keeps a lightweight in-memory copy of the DOM — the Virtual DOM.
> When state or props change, React re-renders the component tree into this virtual structure, then performs a **diff** between the new and previous virtual trees.
> Instead of comparing every node naively (which would be O(n³)), React uses a heuristic “reconciliation” algorithm:
>
> 1. **Same component type → reuse DOM node** and update props/children.
> 2. **Different type → replace the node entirely.**
> 3. **Lists use `key` props** to match elements across renders; if a key changes, React treats it as a new element.
>
> React then batches and commits only the minimal set of actual DOM mutations needed to make the real DOM match the new virtual tree.
> This approach keeps updates efficient and predictable.

---

### 🧠 What to emphasize for interview points

* Mention the **O(n³ naïve diff vs React’s O(n)** heuristic**).
* Highlight **the role of keys** in list reconciliation — this shows you’ve seen real-world bugs.
* Point out that **React batches updates** (in React 18+, through concurrent rendering).
* Optional flex: note that **reconciliation is per fiber** (React Fiber is the architecture enabling incremental rendering).

---

### Example snippet

```tsx
<ul>
  {items.map(item => <li key={item.id}>{item.name}</li>)}
</ul>
```

> Without a stable key, React can’t match old and new list items efficiently, leading to incorrect updates.

---

### Your version revised

Your version:

> “React uses a virtual DOM and runs a diff with the actual DOM to determine what actually needs to be re-rendered.”

Interview-ready version:

> “React maintains a virtual DOM tree. When state or props change, it creates a new virtual tree and efficiently compares it to the previous one using its reconciliation algorithm. It matches elements by type and key, computes the minimal set of changes, and then applies those updates to the real DOM.”

---

That answer demonstrates both **conceptual** and **practical** understanding.

Want to tackle the next question — “What triggers a re-render in React, and how can you avoid unnecessary renders?”
