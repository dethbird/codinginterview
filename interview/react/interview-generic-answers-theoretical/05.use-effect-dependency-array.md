# 5. Explain **useEffect**‚Äôs dependency array and common mistakes.

## a

    useEffect is called on componendDidMount. The dependency array describes what needs to exist before the enclosing function is fired because it's contents depend on them. 

    One common mistake is using a state variable as a dependency that then gets changed within useState causing an infinite loop. I'm not aware of others.

## A

That‚Äôs a strong starting intuition ‚Äî you‚Äôve captured two big ideas:

1. `useEffect` runs *after* render (like `componentDidMount`).
2. Dependencies control *when* it runs again.

But your phrasing could use a bit more precision and some real-world insight ‚Äî especially around **what the dependency array actually means** and **the most common pitfalls** teams hit.

Let‚Äôs tune it up.

---

### üí° Interview-ready explanation

> `useEffect` lets you run side effects in function components ‚Äî things like data fetching, subscriptions, or manually changing the DOM. It runs **after the render commit phase**.
>
> The **dependency array** tells React *which values the effect depends on*. React compares each value in the array between renders using shallow equality. If any have changed by reference or value, the effect re-runs.
>
> When the array is empty (`[]`), the effect runs only once after the initial mount (and on unmount if a cleanup function is returned).

---

### üß† Common mistakes (and how to explain them)

1. **Infinite re-render loops (the one you mentioned):**

   * Setting state *inside* the effect that‚Äôs *also* a dependency causes it to fire forever.
   * Example:

     ```tsx
     useEffect(() => {
       setCount(count + 1);
     }, [count]); // üö® Infinite loop
     ```

2. **Missing dependencies:**

   * Not including everything the effect *uses* (like props or functions) can cause stale closures or bugs that only appear later.
   * Fix: add dependencies or wrap functions with `useCallback` to stabilize them.

3. **Over-including dependencies:**

   * Including things that change every render (like inline functions or objects) causes unnecessary re-runs.

4. **Misunderstanding cleanup:**

   * Forgetting that the function returned by `useEffect` runs before the next effect or on unmount.
   * Example: unsubscribing from event listeners, aborting fetch requests, clearing timers.

5. **Confusing timing:**

   * `useEffect` runs *after paint*.
     If you need to measure layout or perform synchronous DOM reads before paint, you use **`useLayoutEffect`** instead.

---

### üó£Ô∏è Interview-ready version

> ‚Äú`useEffect` runs side effects after React updates the DOM. The dependency array controls when it re-runs ‚Äî React compares each dependency between renders and only re-executes if one has changed.
>
> The most common mistake is forgetting dependencies, which causes stale closures, or including a piece of state that‚Äôs updated inside the effect, which causes an infinite loop. Another is misunderstanding cleanup ‚Äî the return function runs before re-run or on unmount.
>
> The key is to think of `useEffect` as a synchronization tool: it keeps your component in sync with external systems, not as a lifecycle replacement.‚Äù

---

You‚Äôre getting the hang of how to turn a short intuition into a confident, well-rounded answer.

Next up naturally: **How would you manage global state? When do you pick Context vs Redux vs Zustand?**
Would you like to try that one next?
