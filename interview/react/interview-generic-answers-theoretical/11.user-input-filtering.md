# 11. How do you handle accessibility and keyboard navigation in React components?

## a 

    onKeyUp but I really don't know the full answer to this.

## A

Great—let’s level this up from “`onKeyUp`” to a crisp, senior answer that hits semantics, focus, and ARIA patterns.

### Interview-ready core

* **Semantics first:** Prefer native elements (`<button>`, `<a>`, `<input>`) over `div` soup. Native controls come with keyboard support and roles for free.
* **Keyboard model:** Use **`onKeyDown`** (not `onKeyUp`) for primary interactions. Support **Enter** for “activate” and **Space** for button-like widgets. Don’t bind click to non-interactive elements.
* **Focus management:** Ensure a visible focus style (`:focus-visible`). When opening UI (modal, menu), **move focus inside**, **trap focus** while open, and **restore focus** on close.
* **Roving tabindex:** For composite widgets (menus, tabs, listboxes), manage a single `tabIndex=0` on the active item and `-1` elsewhere; arrow keys move the active item.
* **Announce state:** Use the minimal ARIA needed: `aria-expanded`, `aria-controls`, `aria-selected`, `aria-describedby`, `role="dialog"`/`aria-modal="true"` for modals. Avoid ARIA if semantics already cover it.
* **Accessible name/labeling:** Every control needs a name (`<label for>`, `aria-label`, or text content). Tie errors/help text with `aria-describedby`.
* **Live updates:** For async changes the user didn’t trigger (e.g., background load), use a polite `aria-live="polite"` region.
* **Skip links & landmarks:** Provide `<a href="#main" class="skip-link">Skip to content</a>` and landmark elements (`<header>`, `<nav>`, `<main>`, `<footer>`).

### Tiny examples

**1) Button done right**

```tsx
<button type="button" onClick={doThing} onKeyDown={(e) => {
  if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); doThing(); }
}}>
  Save
</button>
```

**2) Disclosure (details/summary is easiest)**

```tsx
<details>
  <summary>Filters</summary>
  {/* filter content */}
</details>
```

If you roll your own: `<button aria-expanded={open} aria-controls="panel">Filters</button>`

**3) Roving tabindex list**

```tsx
function RovingList({ items }) {
  const [i, setI] = useState(0);
  const refs = useRef<HTMLButtonElement[]>([]);
  return (
    <ul role="listbox" aria-activedescendant={`opt-${i}`} onKeyDown={(e) => {
      if (e.key === 'ArrowDown') setI((v) => Math.min(v+1, items.length-1));
      if (e.key === 'ArrowUp') setI((v) => Math.max(v-1, 0));
      if (e.key === 'Enter') refs.current[i]?.click();
    }}>
      {items.map((item, idx) => (
        <li key={item.id} id={`opt-${idx}`}>
          <button
            ref={(el) => el && (refs.current[idx] = el)}
            role="option"
            tabIndex={idx === i ? 0 : -1}
            aria-selected={idx === i}
            onFocus={() => setI(idx)}
          >
            {item.label}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

### Testing & tooling (what interviewers love to hear)

* **Linting:** `eslint-plugin-jsx-a11y` in CI.
* **Runtime checks:** Storybook + a11y addon; axe-core/`jest-axe` in tests.
* **User tests:** Try with keyboard only (Tab/Shift+Tab/Arrows/Escape). Spot-check with a screen reader (NVDA, VoiceOver).

### Quick elevator pitch you can say aloud

> “I default to native semantics for free keyboard support, add minimal ARIA for state, and manage focus explicitly. For composite widgets I use a roving tabindex pattern with arrow keys. I verify with `eslint-plugin-jsx-a11y`, axe in tests, and quick screen-reader checks. Accessibility is about predictable focus, clear names, and correct roles—then keyboard behavior is just implementing the expected pattern.”

Want to try a quick one next like **“Build an accessible modal: what roles, focus steps, and keys do you support?”**


