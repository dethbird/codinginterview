# 2. “Implement input debouncing and explain tradeoffs vs throttling.”

## a

I would use a state variable and offload to a debounce function. Inside, I would use a setTimeout set to the debounce ms desired. The value would be memoized and only announce when the final setTimeout has executed. Throttling is server side and just limits the number of requests per time frame that can be made, and so mutation requests could be dropped. Honestly I don't know the best answer for this question.

## A

You’re on the right trail. First, a quick tune-up on your answer, then we’ll drop an interview-ready explanation and clean React snippets you can reuse.

## What you got right

* Debouncing uses a timer (`setTimeout`) and only fires **after** the user stops triggering the event for N ms. Good.
* You recognized it’s often implemented at the input layer (e.g., search box) to avoid spamming calls.

## What was missing / slightly off

* Throttling is **not** only server-side. It’s a client- or server-side strategy that ensures a function runs **at most once per interval** (e.g., every 100ms), useful for high-frequency events like `scroll`, `resize`, or rapid clicks.
* Debounce vs throttle tradeoffs: **latency vs throughput**, **leading/trailing edge behavior**, **user-perceived responsiveness**, and **guarantees** (debounce may never fire if input never settles; throttle guarantees periodic updates).
* In React, you usually stabilize handlers with `useCallback`, and you must **clear timers** to avoid stale updates/unmounted-component writes.
* Accessibility: aggressive debouncing can delay feedback; throttling can keep UI feeling alive.

---

## Interview-ready “say it out loud” answer

**“For input debouncing, I delay work until the user pauses. In React, I keep the raw input in local state, then debounce the expensive side-effect (like a search request) by N milliseconds using a timer. Each keystroke resets the timer; only the final quiet period triggers the call. That reduces server load and prevents flicker as the user types.**

**Throttling is the complement: instead of waiting for quiet, it guarantees we run at most once per interval—great for high-frequency events like scroll or window resize where I want steady updates without overwhelming the main thread.**

**Trade-offs: Debounce gives minimal calls but adds latency and risks never firing if the user never pauses. Throttle feels more responsive and bounded but can ‘skip’ intermediate states. I choose debounce for text inputs and autosave; throttle for scroll/drag/resizing and rate-limited click handlers. Implementation-wise, I stabilize handler references with `useCallback`, clear timers on unmount, and pick leading/trailing options depending on whether I want an immediate response or a final one.”**

---

## React implementations you can paste

### 1) Debounce: hook + usage

```tsx
import { useEffect, useRef } from 'react';

/** useDebouncedValue returns a value that updates only after `delay` ms of silence. */
export function useDebouncedValue<T>(value: T, delay = 300) {
  const timeoutRef = useRef<number | null>(null);
  const debouncedRef = useRef(value);

  useEffect(() => {
    if (timeoutRef.current) clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(() => {
      debouncedRef.current = value;
      // trigger a re-render by setting state if you prefer;
      // this version returns the latest ref via a getter pattern below
    }, delay);

    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, [value, delay]);

  // Simple pattern: return the latest stable value via a getter function
  // For most UIs, an alternative is to store `debounced` in state.
  return debouncedRef.current;
}
```

A more typical state-based debounce (simpler to consume):

```tsx
import { useEffect, useState } from 'react';

export function useDebouncedState<T>(value: T, delay = 300) {
  const [debounced, setDebounced] = useState(value);
  useEffect(() => {
    const t = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(t);
  }, [value, delay]);
  return debounced;
}
```

Usage in a search box:

```tsx
import { useState, useMemo, useCallback } from 'react';
import { useDebouncedState } from './useDebouncedState';

function SearchBox({ queryServer }: { queryServer: (q: string) => void }) {
  const [input, setInput] = useState('');
  const debouncedQuery = useDebouncedState(input, 400);

  // fire the query when the debounced value changes
  useEffect(() => {
    if (debouncedQuery.trim()) queryServer(debouncedQuery);
  }, [debouncedQuery, queryServer]);

  const onChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => setInput(e.target.value),
    []
  );

  return <input value={input} onChange={onChange} placeholder="Search…" />;
}
```

### 2) Throttle: hook + usage

```tsx
import { useEffect, useRef, useState } from 'react';

/** useThrottledValue emits at most once per `interval` ms (keeps last seen value). */
export function useThrottledValue<T>(value: T, interval = 100) {
  const [throttled, setThrottled] = useState(value);
  const lastRan = useRef(0);
  const lastValue = useRef(value);
  lastValue.current = value;

  useEffect(() => {
    const now = Date.now();
    const remaining = interval - (now - lastRan.current);

    if (remaining <= 0) {
      setThrottled(lastValue.current);
      lastRan.current = now;
    } else {
      const id = setTimeout(() => {
        setThrottled(lastValue.current);
        lastRan.current = Date.now();
      }, remaining);
      return () => clearTimeout(id);
    }
  }, [value, interval]);

  return throttled;
}
```

Usage for scroll/resize:

```tsx
function ScrollPercent() {
  const [scrollY, setScrollY] = useState(0);
  const onScroll = useCallback(() => setScrollY(window.scrollY), []);

  useEffect(() => {
    window.addEventListener('scroll', onScroll, { passive: true });
    return () => window.removeEventListener('scroll', onScroll);
  }, [onScroll]);

  const displayY = useThrottledValue(scrollY, 100);
  return <div>ScrollY: {displayY}</div>;
}
```

> For ultra-smooth UI work (drag, resize), consider a `requestAnimationFrame` throttle to align updates with the paint loop.

---

## Choosing options (leading/trailing)

* **Debounce trailing=true (default):** Waits for quiet time; good for search.
* **Debounce leading=true, trailing=false:** Fire immediately on first input, then silence—rare, but useful for “instant feedback, then chill.”
* **Throttle leading=true, trailing=true:** Fire immediately, then at most once per window, and once more at the end with the latest value (great UX for sliders/drag).

(Lodash exposes these; you can mirror the options if you roll your own.)

---

## Quick test ideas (unit-test mindset)

* Debounce: simulate rapid updates, assert no calls until delay passes; assert exactly one call with last value; assert timer cleared on unmount.
* Throttle: simulate bursts; assert invocations don’t exceed ⌈duration/interval⌉; verify trailing call behavior.
* React: ensure hooks don’t cause setState on unmounted components (no act() warnings).

---

## TL;DR

* **Debounce:** wait for quiet → minimal calls, higher latency, risk of “never fires.” Use for text input/search/autosave.
* **Throttle:** steady cadence → bounded calls, more responsive, may skip intermediates. Use for scroll/drag/resize/click-spam guards.
* Both can live on **client or server**; pick based on UX and resource constraints, not dogma.

If you want, I can bundle these into a tiny `utils/async.ts` with type-safe signatures and Jest tests so you can drop it into any project.
